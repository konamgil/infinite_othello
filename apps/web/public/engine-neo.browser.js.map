{
  "version": 3,
  "sources": ["../../../packages/core/src/bitboard.ts", "../../../packages/core/src/gameCore.ts", "../../../packages/core/src/GameStateManager.ts", "../../../packages/core/src/SearchWorkerManager.ts", "../../../packages/core/src/index.ts", "../../../packages/engine-neo/src/optimization/transTable.ts", "../../../packages/engine-neo/src/evaluation/weights.ts", "../../../packages/engine-neo/src/evaluation/mobility.ts", "../../../packages/engine-neo/src/ordering/moveOrdering.ts", "../../../packages/engine-neo/src/evaluation/stability.ts", "../../../packages/engine-neo/src/evaluation/heuristic.ts", "../../../packages/engine-neo/src/search/pvs.ts", "../../../packages/engine-neo/src/config/selectivity.ts", "../../../packages/engine-neo/src/search/aspiration.ts", "../../../packages/engine-neo/src/search/timeManager.ts", "../../../packages/engine-neo/src/index.ts"],
  "sourcesContent": ["// public/js/ai/neo/bitboard.ts\n// BigInt Bitboard Kernel + Kifu utils + Legacy-compatible Board API\n// \uAE30\uBCF8 1D Uint8Array(\uAE38\uC774 64, 0/1/2) \uBCF4\uB4DC\uB97C \uAE30\uBC18\uC73C\uB85C \uB3D9\uC791\uD568\n// \uB0B4\uBD80\uC801\uC73C\uB85C BigInt \uBE44\uD2B8\uBCF4\uB4DC(bp/wp)\uB85C \uACC4\uC0B0\uD558\uACE0, flip/undo\uC758 \uACE0\uC18D \uAE30\uB2A5(__native)\uC81C\uACF5\n\nimport type { Board, Player, Position } from 'shared-types';\n\nexport const FILE_A = 0x0101010101010101n;\nexport const FILE_H = 0x8080808080808080n;\nexport const ALL_ONES = 0xffffffffffffffffn;\n\nexport const NOT_FILE_A = ALL_ONES ^ FILE_A;\nexport const NOT_FILE_H = ALL_ONES ^ FILE_H;\n\n// \uBC29\uD5A5 shift \uD568\uC218\uB4E4\nexport function shiftEast(bb: bigint): bigint { return (bb & NOT_FILE_H) << 1n; }\nexport function shiftWest(bb: bigint): bigint { return (bb & NOT_FILE_A) >> 1n; }\nexport function shiftNorth(bb: bigint): bigint { return bb << 8n; }\nexport function shiftSouth(bb: bigint): bigint { return bb >> 8n; }\nexport function shiftNorthEast(bb: bigint): bigint { return (bb & NOT_FILE_H) << 9n; }\nexport function shiftNorthWest(bb: bigint): bigint { return (bb & NOT_FILE_A) << 7n; }\nexport function shiftSouthEast(bb: bigint): bigint { return (bb & NOT_FILE_H) >> 7n; }\nexport function shiftSouthWest(bb: bigint): bigint { return (bb & NOT_FILE_A) >> 9n; }\n\ntype ShiftFunction = (bb: bigint) => bigint;\n\nconst DIRS: ShiftFunction[] = [\n  shiftEast, shiftWest, shiftNorth, shiftSouth,\n  shiftNorthEast, shiftNorthWest, shiftSouthEast, shiftSouthWest\n];\n\n// \uBE44\uD2B8 \uC5F0\uC0B0 \uC720\uD2F8\uB9AC\uD2F0\nexport function bitCount(bb: bigint): number {\n  let cnt = 0;\n  let x = BigInt(bb);\n  while (x) { cnt++; x &= x - 1n; }\n  return cnt;\n}\n\nexport function bitIndex(lsb: bigint): number {\n  let i = 0n, t = BigInt(lsb);\n  while (t > 1n) { t >>= 1n; i++; }\n  return Number(i);\n}\n\n// \uC88C\uD45C \uBCC0\uD658 \uD568\uC218\n\nexport function rcToBitIndex(row: number, col: number): number { \n  return (7 - row) * 8 + col; \n}\n\nexport function bitIndexToRC(idx: number): [number, number] {\n  if (idx < 0 || idx > 63) throw new Error('Invalid bit index: ' + idx);\n  const rowFromBottom = (idx / 8) | 0;\n  const row = 7 - rowFromBottom;\n  const col = idx % 8;\n  return [row, col];\n}\n\nexport function rcToMask(row: number, col: number): bigint { \n  return 1n << BigInt(rcToBitIndex(row, col)); \n}\n\nexport function maskToRCList(mask: bigint): Position[] {\n  const out: Position[] = [];\n  let bb = BigInt(mask);\n  while (bb) {\n    const lsb = bb & -bb;\n    const idx = bitIndex(lsb);\n    const [row, col] = bitIndexToRC(idx);\n    out.push({ row, col });\n    bb ^= lsb;\n  }\n  return out;\n}\n\n\n// \uB0B4\uBD80 \uD5EC\uD37C \uD568\uC218\uB4E4\nfunction isTypedArray(a: any): a is Uint8Array {\n  return a && typeof a.length === 'number' && typeof a.subarray === 'function';\n}\n\nfunction flattenBoard(board2d: Board): Uint8Array {\n  const out = new Uint8Array(64);\n  for (let r = 0; r < 8; r++) {\n    for (let c = 0; c < 8; c++) {\n      const cell = board2d[r][c];\n      out[r * 8 + c] = cell === 'black' ? 1 : cell === 'white' ? 2 : 0;\n    }\n  }\n  return out;\n}\n\nfunction computeBitboards(cells: Uint8Array): { bp: bigint; wp: bigint } {\n  let bp = 0n, wp = 0n;\n  for (let i = 0; i < 64; i++) {\n    const v = cells[i] | 0;\n    if (v === 0) continue;\n    const r = (i / 8) | 0;\n    const c = i % 8;\n    const idx = rcToBitIndex(r, c);\n    const mask = 1n << BigInt(idx);\n    if (v === 1) bp |= mask;\n    else if (v === 2) wp |= mask;\n  }\n  return { bp, wp };\n}\n\n// \uD655\uC7A5\uB41C \uBCF4\uB4DC \uD0C0\uC785 (\uBE44\uD2B8\uBCF4\uB4DC \uCE90\uC2DC \uD3EC\uD568)\nexport interface BitBoard extends Uint8Array {\n  _bp?: bigint;  // black pieces bitboard\n  _wp?: bigint;  // white pieces bitboard\n}\n\nfunction sideBB(board: BitBoard, side: number): bigint {\n  return side === 1 ? board._bp! : board._wp!;\n}\n\nfunction oppBB(board: BitBoard, side: number): bigint {\n  return side === 1 ? board._wp! : board._bp!;\n}\n\nfunction setSideBB(board: BitBoard, side: number, bb: bigint): void {\n  if (side === 1) board._bp = bb;\n  else board._wp = bb;\n}\n\n// \uACF5\uAC1C API\n/** Ensure 1D Uint8Array board and attach bitboards cache. */\nexport function ensureBoard(board: Board | BitBoard | Uint8Array | any): BitBoard {\n  let b: BitBoard;\n  if (!isTypedArray(board)) {\n    if (Array.isArray(board) && Array.isArray(board[0])) {\n      b = flattenBoard(board as Board) as BitBoard;\n    } else if (Array.isArray(board)) {\n      b = Uint8Array.from(board) as BitBoard;\n    } else if (board && board.cells && isTypedArray(board.cells)) {\n      b = board.cells as BitBoard;\n    } else {\n      b = new Uint8Array(64) as BitBoard; // fallback empty\n    }\n  } else {\n    b = board as BitBoard;\n  }\n  \n  if (b._bp === undefined || b._wp === undefined) {\n    const { bp, wp } = computeBitboards(b);\n    b._bp = bp;\n    b._wp = wp;\n  }\n  return b;\n}\n\nfunction dirMoveGen(p: bigint, o: bigint, shiftFn: ShiftFunction): bigint {\n  // Repeatedly expand opponent rays, then one more shift into empty squares\n  let m = shiftFn(p) & o;\n  // up to 5 more steps sufficient on 8x8\n  m |= shiftFn(m) & o;\n  m |= shiftFn(m) & o;\n  m |= shiftFn(m) & o;\n  m |= shiftFn(m) & o;\n  m |= shiftFn(m) & o;\n  return shiftFn(m);\n}\n\nexport function getValidMovesMask(side: number, board: Board | BitBoard): bigint {\n  const b = ensureBoard(board);\n  const p = side === 1 ? b._bp! : b._wp!;\n  const o = side === 1 ? b._wp! : b._bp!;\n  const empty = ~(p | o) & ALL_ONES;\n\n  let moves = 0n;\n  for (const f of DIRS) {\n    moves |= dirMoveGen(p, o, f);\n  }\n  return moves & empty;\n}\n\n// Convert Player to numeric side for internal bitboard operations\nfunction playerToSide(player: Player): number {\n  return player === 'black' ? 1 : 2;\n}\n\nexport function getValidMovesBitboard(player: Player, board: Board | BitBoard): Position[] {\n  const side = playerToSide(player);\n  const mask = getValidMovesMask(side, board);\n  return maskToRCList(mask);\n}\n\nfunction flipsForMove(p: bigint, o: bigint, moveMask: bigint): bigint {\n  let flips = 0n;\n  // For each dir, accumulate opponent until we meet own piece\n  let x: bigint, cap: bigint;\n  \n  // East\n  x = shiftEast(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftEast(x); }\n  if (x & p) flips |= cap;\n  \n  // West\n  x = shiftWest(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftWest(x); }\n  if (x & p) flips |= cap;\n  \n  // North\n  x = shiftNorth(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftNorth(x); }\n  if (x & p) flips |= cap;\n  \n  // South\n  x = shiftSouth(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftSouth(x); }\n  if (x & p) flips |= cap;\n  \n  // NE\n  x = shiftNorthEast(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftNorthEast(x); }\n  if (x & p) flips |= cap;\n  \n  // NW\n  x = shiftNorthWest(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftNorthWest(x); }\n  if (x & p) flips |= cap;\n  \n  // SE\n  x = shiftSouthEast(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftSouthEast(x); }\n  if (x & p) flips |= cap;\n  \n  // SW\n  x = shiftSouthWest(moveMask); cap = 0n;\n  while (x && (x & o)) { cap |= x; x = shiftSouthWest(x); }\n  if (x & p) flips |= cap;\n\n  return flips;\n}\n\nexport function isValidMoveBitboard(row: number, col: number, player: Player, board: Board | BitBoard): boolean {\n  const side = playerToSide(player);\n  const b = ensureBoard(board);\n  const moveMask = rcToMask(row, col);\n  const p = side === 1 ? b._bp! : b._wp!;\n  const o = side === 1 ? b._wp! : b._bp!;\n  if ((moveMask & (p | o)) !== 0n) return false;\n  const flips = flipsForMove(p, o, moveMask);\n  return flips !== 0n;\n}\n\nexport interface MoveToken {\n  __native: true;\n  side: number;\n  row: number;\n  col: number;\n  moveMask: bigint;\n  flips: bigint;\n  prevBP: bigint;\n  prevWP: bigint;\n}\n\nexport function flipPieces(board: Board | BitBoard, row: number, col: number, player: Player): MoveToken | undefined {\n  const side = playerToSide(player);\n  const b = ensureBoard(board);\n  const moveMask = rcToMask(row, col);\n  const p = side === 1 ? b._bp! : b._wp!;\n  const o = side === 1 ? b._wp! : b._bp!;\n  if ((moveMask & (p | o)) !== 0n) return undefined; // occupied\n  const flips = flipsForMove(p, o, moveMask);\n  if (!flips) return undefined; // illegal\n\n  const prevBP = b._bp!;\n  const prevWP = b._wp!;\n\n  // apply\n  const newP = p | moveMask | flips;\n  const newO = o & ~flips;\n  if (side === 1) { b._bp = newP; b._wp = newO; }\n  else { b._wp = newP; b._bp = newO; }\n\n  // update cells only for changed bits\n  const changeMask = flips | moveMask;\n  let m = changeMask;\n  while (m) {\n    const lsb = m & -m;\n    const idx = bitIndex(lsb);\n    b[idx] = side;\n    m ^= lsb;\n  }\n\n  const token: MoveToken = { __native: true, side, row, col, moveMask, flips, prevBP, prevWP };\n  return token;\n}\n\nexport function undoMove(board: Board | BitBoard, token: MoveToken, _sideIgnored?: number): void {\n  const b = ensureBoard(board);\n  if (!token || !token.__native) return;\n  // revert bitboards\n  b._bp = token.prevBP;\n  b._wp = token.prevWP;\n\n  // revert cells only where changed (move cell + flips)\n  const changeMask = token.flips | token.moveMask;\n  let m = changeMask;\n  while (m) {\n    const lsb = m & -m;\n    const idx = bitIndex(lsb);\n    // Determine original color from prev bitboards\n    const bit = 1n << BigInt(idx);\n    const wasBlack = (token.prevBP & bit) !== 0n;\n    const wasWhite = (token.prevWP & bit) !== 0n;\n    b[idx] = wasBlack ? 1 : wasWhite ? 2 : 0;\n    m ^= lsb;\n  }\n}\n\nexport function emptiesCount(board: Board | BitBoard): number {\n  const b = ensureBoard(board);\n  const occ = b._bp! | b._wp!;\n  return bitCount((~occ) & ALL_ONES);\n}\n\n// Deterministic lightweight hash\nexport function computeZobristHash(board: Board | BitBoard, player: Player): number {\n  const side = playerToSide(player);\n  const b = ensureBoard(board);\n  // simple mixing of bigints; not true zobrist, but fast and stable\n  const prime1 = 0x100000001b3n;\n  const prime2 = 0x100000001b5n;\n  let h = 0xcbf29ce484222325n;\n  h ^= (b._bp! * prime1) & ALL_ONES; h *= prime2;\n  h ^= (b._wp! * prime2) & ALL_ONES; h *= prime1;\n  h ^= BigInt(side & 3);\n  h *= 0x100000001b7n;\n  return Number(h & 0xffffffffffffffffn);\n}\n", "// Complete Othello game logic with unified type system\r\n// Bridges shared-types (UI layer) \u2194 bitboard (performance layer)\r\n\r\nimport type {\n  GameCore,\n  Board,\n  Cell,\n  Player,\n  Position,\n  Move,\n  MoveResult,\n  GameResult,\n  Score,\r\n  GameStatus,\r\n  MoveFailureReason\r\n} from 'shared-types';\r\n\r\nimport {\n  BitBoard,\n  ensureBoard,\n  getValidMovesBitboard,\n  isValidMoveBitboard,\n  flipPieces,\n  undoMove,\n  emptiesCount,\n  computeZobristHash,\n  MoveToken\n} from './bitboard';\n\r\n// ===== TYPE ADAPTERS =====\r\n\r\n/**\r\n * Convert shared-types Board (2D Cell[][]) to BitBoard (1D Uint8Array)\r\n */\r\nfunction boardToBitBoard(board: Board): BitBoard {\r\n  const bitBoard = new Uint8Array(64) as BitBoard;\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      const cell = board[row][col];\r\n      const index = row * 8 + col;\r\n\r\n      if (cell === 'black') {\r\n        bitBoard[index] = 1;\r\n      } else if (cell === 'white') {\r\n        bitBoard[index] = 2;\r\n      } else {\r\n        bitBoard[index] = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  return bitBoard;\r\n}\r\n\r\n/**\r\n * Convert BitBoard (1D Uint8Array) to shared-types Board (2D Cell[][])\r\n */\r\nfunction bitBoardToBoard(bitBoard: BitBoard): Board {\n  const board: Board = [];\n\n  for (let row = 0; row < 8; row++) {\n    const rowCells: Cell[] = [];\n    for (let col = 0; col < 8; col++) {\n      const index = row * 8 + col;\n      const value = bitBoard[index];\n\n      if (value === 1) {\r\n        rowCells.push('black');\r\n      } else if (value === 2) {\r\n        rowCells.push('white');\r\n      } else {\r\n        rowCells.push(null);\r\n      }\r\n    }\r\n    board.push(rowCells);\r\n  }\r\n\r\n  return board;\r\n}\r\n\r\n// ===== CORE GAME LOGIC =====\r\n\r\n/**\r\n * Create initial Othello game state\r\n */\r\nexport function createInitialGameCore(gameId: string = crypto.randomUUID()): GameCore {\n  // Create initial board with starting position\n  const board: Board = Array.from({ length: 8 }, () => new Array<Cell>(8).fill(null));\n\r\n  // Set initial pieces (center 4 squares)\r\n  board[3][3] = 'white';\r\n  board[3][4] = 'black';\r\n  board[4][3] = 'black';\r\n  board[4][4] = 'white';\r\n\r\n  const validMoves = getValidMoves(board, 'black');\r\n\r\n  return {\r\n    id: gameId,\r\n    board,\r\n    currentPlayer: 'black',\r\n    validMoves,\r\n    score: { black: 2, white: 2 },\r\n    status: 'playing',\r\n    moveHistory: [],\r\n    canUndo: false,\r\n    canRedo: false\r\n  };\r\n}\r\n\r\n/**\r\n * Get all valid moves for a player\r\n */\r\nexport function getValidMoves(board: Board, player: Player): Position[] {\n  const bitBoard = ensureBoard(boardToBitBoard(board));\n  return getValidMovesBitboard(player, bitBoard);\n}\n\r\n/**\r\n * Check if a move is valid\r\n */\r\nexport function isValidMove(board: Board, position: Position, player: Player): boolean {\r\n  const bitBoard = ensureBoard(boardToBitBoard(board));\r\n  return isValidMoveBitboard(position.row, position.col, player, bitBoard);\r\n}\r\n\r\n/**\r\n * Apply a move and return the result\r\n */\r\nexport function makeMove(gameCore: GameCore, position: Position): MoveResult {\r\n  // Validate move\r\n  if (gameCore.status !== 'playing') {\r\n    return {\r\n      success: false,\r\n      reason: 'game_finished',\r\n      message: 'Game is not in playing state'\r\n    };\r\n  }\r\n\r\n  if (gameCore.currentPlayer === 'black' || gameCore.currentPlayer === 'white') {\r\n    // Player validation passed\r\n  } else {\r\n    return {\r\n      success: false,\r\n      reason: 'not_your_turn',\r\n      message: 'Invalid current player'\r\n    };\r\n  }\r\n\r\n  const bitBoard = ensureBoard(boardToBitBoard(gameCore.board));\r\n\r\n  if (!isValidMoveBitboard(position.row, position.col, gameCore.currentPlayer, bitBoard)) {\r\n    if (bitBoard[position.row * 8 + position.col] !== 0) {\r\n      return {\r\n        success: false,\r\n        reason: 'occupied',\r\n        message: 'Position is already occupied'\r\n      };\r\n    } else {\r\n      return {\r\n        success: false,\r\n        reason: 'no_captures',\r\n        message: 'Move would not capture any pieces'\r\n      };\r\n    }\r\n  }\r\n\r\n  // Apply the move\r\n  const moveToken = flipPieces(bitBoard, position.row, position.col, gameCore.currentPlayer);\r\n\r\n  if (!moveToken) {\r\n    return {\r\n      success: false,\r\n      reason: 'invalid_position',\r\n      message: 'Failed to apply move'\r\n    };\r\n  }\r\n\r\n  // Convert back to Board format\r\n  const newBoard = bitBoardToBoard(bitBoard);\r\n\r\n  // Determine captured cells by comparing old and new boards\r\n  const capturedCells: Position[] = [];\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      if (gameCore.board[row][col] !== newBoard[row][col] && !(row === position.row && col === position.col)) {\r\n        capturedCells.push({ row, col });\r\n      }\r\n    }\r\n  }\r\n\r\n  // Create the move record\r\n  const move: Move = {\r\n    row: position.row,\r\n    col: position.col,\r\n    player: gameCore.currentPlayer,\r\n    capturedCells,\r\n    timestamp: Date.now()\r\n  };\r\n\r\n  // Calculate new score\r\n  const newScore = calculateScore(newBoard);\r\n\r\n  // Determine next player and status\r\n  const nextPlayer: Player = gameCore.currentPlayer === 'black' ? 'white' : 'black';\r\n  const nextValidMoves = getValidMoves(newBoard, nextPlayer);\r\n\r\n  // Check if next player can move\r\n  let actualNextPlayer = nextPlayer;\r\n  let finalValidMoves = nextValidMoves;\r\n  let gameStatus: GameStatus = 'playing';\r\n\r\n  if (nextValidMoves.length === 0) {\r\n    // Next player has no moves, check if current player can move\r\n    const currentPlayerMoves = getValidMoves(newBoard, gameCore.currentPlayer);\r\n    if (currentPlayerMoves.length === 0) {\r\n      // Neither player can move - game over\r\n      gameStatus = 'finished';\r\n      finalValidMoves = [];\r\n    } else {\r\n      // Current player continues (skip next player's turn)\r\n      actualNextPlayer = gameCore.currentPlayer;\r\n      finalValidMoves = currentPlayerMoves;\r\n    }\r\n  }\r\n\r\n  // Create new game state\r\n  const newGameCore: GameCore = {\r\n    ...gameCore,\r\n    board: newBoard,\r\n    currentPlayer: actualNextPlayer,\r\n    validMoves: finalValidMoves,\r\n    score: newScore,\r\n    status: gameStatus,\r\n    moveHistory: [...gameCore.moveHistory, move],\r\n    canUndo: true,\r\n    canRedo: false\r\n  };\r\n\r\n  return {\r\n    success: true,\r\n    move,\r\n    newGameCore,\r\n    capturedCells\r\n  };\r\n}\r\n\r\n/**\r\n * Calculate score from board\r\n */\r\nexport function calculateScore(board: Board): Score {\r\n  let black = 0;\r\n  let white = 0;\r\n\r\n  for (let row = 0; row < 8; row++) {\r\n    for (let col = 0; col < 8; col++) {\r\n      const cell = board[row][col];\r\n      if (cell === 'black') black++;\r\n      else if (cell === 'white') white++;\r\n    }\r\n  }\r\n\r\n  return { black, white };\r\n}\r\n\r\n/**\r\n * Check if game is over\r\n */\r\nexport function isGameOver(gameCore: GameCore): boolean {\r\n  if (gameCore.status === 'finished') return true;\r\n\r\n  // Game is over if neither player has valid moves\r\n  const currentPlayerMoves = getValidMoves(gameCore.board, gameCore.currentPlayer);\r\n  if (currentPlayerMoves.length > 0) return false;\r\n\r\n  const otherPlayer: Player = gameCore.currentPlayer === 'black' ? 'white' : 'black';\r\n  const otherPlayerMoves = getValidMoves(gameCore.board, otherPlayer);\r\n\r\n  return otherPlayerMoves.length === 0;\r\n}\r\n\r\n/**\r\n * Get final game result\r\n */\r\nexport function getGameResult(gameCore: GameCore): GameResult | null {\r\n  if (!isGameOver(gameCore)) return null;\r\n\r\n  const score = calculateScore(gameCore.board);\r\n  let winner: Player | 'draw';\r\n\r\n  if (score.black > score.white) {\r\n    winner = 'black';\r\n  } else if (score.white > score.black) {\r\n    winner = 'white';\r\n  } else {\r\n    winner = 'draw';\r\n  }\r\n\r\n  return {\r\n    winner,\r\n    score,\r\n    endReason: 'normal',\r\n    duration: 0, // Should be calculated from game start time\r\n    totalMoves: gameCore.moveHistory.length\r\n  };\r\n}\r\n\r\n/**\r\n * Get position hash for transposition tables\r\n */\r\nexport function getPositionHash(gameCore: GameCore): number {\r\n  const bitBoard = ensureBoard(boardToBitBoard(gameCore.board));\r\n  return computeZobristHash(bitBoard, gameCore.currentPlayer);\r\n}\r\n\r\n/**\r\n * Check if position is terminal (game over)\r\n */\r\nexport function isTerminalPosition(gameCore: GameCore): boolean {\r\n  return isGameOver(gameCore);\r\n}\r\n\r\n/**\r\n * Get mobility count (number of valid moves)\r\n */\r\nexport function getMobility(board: Board, player: Player): number {\r\n  return getValidMoves(board, player).length;\r\n}\r\n\r\n/**\r\n * Get empty squares count\r\n */\r\nexport function getEmptySquares(board: Board): number {\r\n  const bitBoard = ensureBoard(boardToBitBoard(board));\r\n  return emptiesCount(bitBoard);\r\n}\r\n\r\n/**\r\n * Convert GameCore to a format suitable for engines\r\n */\r\nexport function gameCoreForEngine(gameCore: GameCore): {\r\n  board: BitBoard;\r\n  currentPlayer: Player;\r\n  validMoves: Position[];\r\n  score: Score;\r\n} {\r\n  const bitBoard = ensureBoard(boardToBitBoard(gameCore.board));\r\n\r\n  return {\r\n    board: bitBoard,\r\n    currentPlayer: gameCore.currentPlayer,\r\n    validMoves: [...gameCore.validMoves],\r\n    score: gameCore.score\r\n  };\r\n}\n", "// High-level game state manager with undo/redo, validation, and history\r\n// Manages complete game lifecycle with event system\r\n\r\nimport type {\r\n  GameCore,\r\n  Player,\r\n  Position,\r\n  Move,\r\n  MoveResult,\r\n  GameResult,\r\n  GameStatus\r\n} from 'shared-types';\r\n\r\nimport {\r\n  createInitialGameCore,\r\n  makeMove,\r\n  isValidMove,\r\n  getValidMoves,\r\n  isGameOver,\r\n  getGameResult,\r\n  calculateScore,\r\n  getPositionHash\r\n} from './gameCore';\r\n\r\n// Event system\r\nexport type GameEvent =\r\n  | { type: 'move_made'; move: Move; gameCore: GameCore }\r\n  | { type: 'game_over'; result: GameResult }\r\n  | { type: 'turn_changed'; player: Player }\r\n  | { type: 'game_started'; gameCore: GameCore }\r\n  | { type: 'game_reset'; gameCore: GameCore }\r\n  | { type: 'move_undone'; gameCore: GameCore }\r\n  | { type: 'move_redone'; gameCore: GameCore };\r\n\r\nexport type GameEventListener = (event: GameEvent) => void;\r\n\r\nexport interface GameStateManagerConfig {\r\n  maxHistorySize: number;\r\n  enableUndo: boolean;\r\n  enableRedo: boolean;\r\n  autoSave: boolean;\r\n}\r\n\r\nexport class GameStateManager {\r\n  private _currentGame: GameCore;\r\n  private _gameHistory: GameCore[] = [];\r\n  private _redoStack: GameCore[] = [];\r\n  private _listeners: GameEventListener[] = [];\r\n  private _config: GameStateManagerConfig;\r\n\r\n  constructor(config: Partial<GameStateManagerConfig> = {}) {\r\n    this._config = {\r\n      maxHistorySize: config.maxHistorySize || 100,\r\n      enableUndo: config.enableUndo ?? true,\r\n      enableRedo: config.enableRedo ?? true,\r\n      autoSave: config.autoSave ?? false\r\n    };\r\n\r\n    this._currentGame = createInitialGameCore();\r\n    this._gameHistory.push({ ...this._currentGame });\r\n\r\n    this.emit({ type: 'game_started', gameCore: this._currentGame });\r\n  }\r\n\r\n  // ===== PUBLIC API =====\r\n\r\n  /**\r\n   * Get current game state (immutable)\r\n   */\r\n  get currentGame(): Readonly<GameCore> {\r\n    return this._currentGame;\r\n  }\r\n\r\n  /**\r\n   * Get current player\r\n   */\r\n  get currentPlayer(): Player {\r\n    return this._currentGame.currentPlayer;\r\n  }\r\n\r\n  /**\r\n   * Get valid moves for current player\r\n   */\r\n  get validMoves(): readonly Position[] {\r\n    return this._currentGame.validMoves;\r\n  }\r\n\r\n  /**\r\n   * Get current score\r\n   */\r\n  get score() {\r\n    return this._currentGame.score;\r\n  }\r\n\r\n  /**\r\n   * Check if game is over\r\n   */\r\n  get isGameOver(): boolean {\r\n    return isGameOver(this._currentGame);\r\n  }\r\n\r\n  /**\r\n   * Get game result if finished\r\n   */\r\n  get gameResult(): GameResult | null {\r\n    return getGameResult(this._currentGame);\r\n  }\r\n\r\n  /**\r\n   * Can undo last move\r\n   */\r\n  get canUndo(): boolean {\r\n    return this._config.enableUndo && this._gameHistory.length > 1;\r\n  }\r\n\r\n  /**\r\n   * Can redo last undone move\r\n   */\r\n  get canRedo(): boolean {\r\n    return this._config.enableRedo && this._redoStack.length > 0;\r\n  }\r\n\r\n  /**\r\n   * Make a move\r\n   */\r\n  makeMove(position: Position): MoveResult {\r\n    if (this.isGameOver) {\r\n      return {\r\n        success: false,\r\n        reason: 'game_finished',\r\n        message: 'Game is already finished'\r\n      };\r\n    }\r\n\r\n    const result = makeMove(this._currentGame, position);\r\n\r\n    if (result.success) {\r\n      // Update state\r\n      this._currentGame = result.newGameCore;\r\n\r\n      // Clear redo stack when new move is made\r\n      this._redoStack = [];\r\n\r\n      // Add to history (with size limit)\r\n      this._gameHistory.push({ ...this._currentGame });\r\n      if (this._gameHistory.length > this._config.maxHistorySize) {\r\n        this._gameHistory.shift();\r\n      }\r\n\r\n      // Emit events\r\n      this.emit({ type: 'move_made', move: result.move, gameCore: this._currentGame });\r\n\r\n      if (this.isGameOver) {\r\n        const gameResult = this.gameResult;\r\n        if (gameResult) {\r\n          this.emit({ type: 'game_over', result: gameResult });\r\n        }\r\n      } else {\r\n        this.emit({ type: 'turn_changed', player: this._currentGame.currentPlayer });\r\n      }\r\n\r\n      // Auto-save if enabled\r\n      if (this._config.autoSave) {\r\n        this.saveToStorage();\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Undo last move\r\n   */\r\n  undo(): boolean {\r\n    if (!this.canUndo) return false;\r\n\r\n    // Move current state to redo stack\r\n    this._redoStack.push({ ...this._currentGame });\r\n\r\n    // Remove current state from history\r\n    this._gameHistory.pop();\r\n\r\n    // Restore previous state\r\n    const previousState = this._gameHistory[this._gameHistory.length - 1];\r\n    this._currentGame = { ...previousState };\r\n\r\n    this.emit({ type: 'move_undone', gameCore: this._currentGame });\r\n    this.emit({ type: 'turn_changed', player: this._currentGame.currentPlayer });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Redo last undone move\r\n   */\r\n  redo(): boolean {\r\n    if (!this.canRedo) return false;\r\n\r\n    // Get state from redo stack\r\n    const nextState = this._redoStack.pop()!;\r\n    this._currentGame = nextState;\r\n\r\n    // Add to history\r\n    this._gameHistory.push({ ...this._currentGame });\r\n\r\n    this.emit({ type: 'move_redone', gameCore: this._currentGame });\r\n    this.emit({ type: 'turn_changed', player: this._currentGame.currentPlayer });\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Reset game to initial state\r\n   */\r\n  reset(): void {\r\n    this._currentGame = createInitialGameCore();\r\n    this._gameHistory = [{ ...this._currentGame }];\r\n    this._redoStack = [];\r\n\r\n    this.emit({ type: 'game_reset', gameCore: this._currentGame });\r\n    this.emit({ type: 'game_started', gameCore: this._currentGame });\r\n  }\r\n\r\n  /**\r\n   * Check if a move is valid\r\n   */\r\n  isValidMove(position: Position): boolean {\r\n    return isValidMove(this._currentGame.board, position, this._currentGame.currentPlayer);\r\n  }\r\n\r\n  /**\r\n   * Get all valid moves for current player\r\n   */\r\n  getValidMoves(): Position[] {\r\n    return getValidMoves(this._currentGame.board, this._currentGame.currentPlayer) as Position[];\r\n  }\r\n\r\n  /**\r\n   * Set game status\r\n   */\r\n  setGameStatus(status: GameStatus): void {\r\n    if (this._currentGame.status !== status) {\r\n      this._currentGame = {\r\n        ...this._currentGame,\r\n        status\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get position hash (for engines/caching)\r\n   */\r\n  getPositionHash(): number {\r\n    return getPositionHash(this._currentGame);\r\n  }\r\n\r\n  /**\r\n   * Get move history\r\n   */\r\n  getMoveHistory(): readonly Move[] {\r\n    return this._currentGame.moveHistory;\r\n  }\r\n\r\n  /**\r\n   * Get game statistics\r\n   */\r\n  getGameStats() {\r\n    return {\r\n      totalMoves: this._currentGame.moveHistory.length,\r\n      score: this._currentGame.score,\r\n      gameId: this._currentGame.id,\r\n      currentPlayer: this._currentGame.currentPlayer,\r\n      status: this._currentGame.status,\r\n      canUndo: this.canUndo,\r\n      canRedo: this.canRedo,\r\n      validMovesCount: this._currentGame.validMoves.length,\r\n      historySize: this._gameHistory.length\r\n    };\r\n  }\r\n\r\n  // ===== EVENT SYSTEM =====\r\n\r\n  /**\r\n   * Add event listener\r\n   */\r\n  addEventListener(listener: GameEventListener): void {\r\n    this._listeners.push(listener);\r\n  }\r\n\r\n  /**\r\n   * Remove event listener\r\n   */\r\n  removeEventListener(listener: GameEventListener): void {\r\n    const index = this._listeners.indexOf(listener);\r\n    if (index !== -1) {\r\n      this._listeners.splice(index, 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Remove all event listeners\r\n   */\r\n  removeAllEventListeners(): void {\r\n    this._listeners = [];\r\n  }\r\n\r\n  private emit(event: GameEvent): void {\r\n    this._listeners.forEach(listener => {\r\n      try {\r\n        listener(event);\r\n      } catch (error) {\r\n        console.error('Error in game event listener:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  // ===== PERSISTENCE =====\r\n\r\n  /**\r\n   * Save game state to localStorage\r\n   */\r\n  saveToStorage(key: string = 'othello-game-state'): void {\r\n    try {\r\n      const saveData = {\r\n        currentGame: this._currentGame,\r\n        gameHistory: this._gameHistory,\r\n        redoStack: this._redoStack,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      localStorage.setItem(key, JSON.stringify(saveData));\r\n    } catch (error) {\r\n      console.error('Failed to save game state:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load game state from localStorage\r\n   */\r\n  loadFromStorage(key: string = 'othello-game-state'): boolean {\r\n    try {\r\n      const saveData = localStorage.getItem(key);\r\n      if (!saveData) return false;\r\n\r\n      const parsed = JSON.parse(saveData);\r\n\r\n      this._currentGame = parsed.currentGame;\r\n      this._gameHistory = parsed.gameHistory || [];\r\n      this._redoStack = parsed.redoStack || [];\r\n\r\n      this.emit({ type: 'game_started', gameCore: this._currentGame });\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to load game state:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Export game as PGN-like format\r\n   */\r\n  exportGame(): string {\r\n    const moves = this._currentGame.moveHistory.map((move, index) => {\r\n      const moveNumber = Math.floor(index / 2) + 1;\r\n      const player = move.player === 'black' ? 'B' : 'W';\r\n      const position = `${String.fromCharCode(97 + move.col)}${move.row + 1}`;\r\n      return `${moveNumber}.${player} ${position}`;\r\n    });\r\n\r\n    const result = this.gameResult;\r\n    const resultStr = result\r\n      ? result.winner === 'draw' ? '1/2-1/2' : result.winner === 'black' ? '1-0' : '0-1'\r\n      : '*';\r\n\r\n    return [\r\n      `[Game \"${this._currentGame.id}\"]`,\r\n      `[Black \"Player\"]`,\r\n      `[White \"Player\"]`,\r\n      `[Result \"${resultStr}\"]`,\r\n      `[Score \"${this._currentGame.score.black}-${this._currentGame.score.white}\"]`,\r\n      '',\r\n      moves.join(' ') + (resultStr !== '*' ? ` ${resultStr}` : '')\r\n    ].join('\\n');\r\n  }\r\n\r\n  // ===== ADVANCED FEATURES =====\r\n\r\n  /**\r\n   * Create a copy of the current game for simulation\r\n   */\r\n  createSimulation(): GameCore {\r\n    return JSON.parse(JSON.stringify(this._currentGame));\r\n  }\r\n\r\n  /**\r\n   * Apply multiple moves for analysis\r\n   */\r\n  simulateMoves(moves: Position[]): GameCore {\r\n    let simulation = this.createSimulation();\r\n\r\n    for (const position of moves) {\r\n      const result = makeMove(simulation, position);\r\n      if (result.success) {\r\n        simulation = result.newGameCore;\r\n      } else {\r\n        break; // Stop on invalid move\r\n      }\r\n    }\r\n\r\n    return simulation;\r\n  }\r\n\r\n  /**\r\n   * Get game state at specific move number\r\n   */\r\n  getGameStateAtMove(moveNumber: number): GameCore | null {\r\n    if (moveNumber < 0 || moveNumber >= this._gameHistory.length) {\r\n      return null;\r\n    }\r\n    return { ...this._gameHistory[moveNumber] };\r\n  }\r\n\r\n  /**\r\n   * Dispose of the manager\r\n   */\r\n  dispose(): void {\r\n    this.removeAllEventListeners();\r\n    this._gameHistory = [];\r\n    this._redoStack = [];\r\n  }\r\n}", "// SearchWorkerManager: Coordinates multiple AI search workers for optimal performance\r\n// Handles work distribution, load balancing, and result aggregation\r\n\r\nimport type {\r\n  GameCore,\r\n  Player,\r\n  Position,\r\n  AIDifficulty\r\n} from 'shared-types';\r\n\r\nimport type {\r\n  SearchRequest,\r\n  SearchResponse,\r\n  SearchError,\r\n  SearchResult,\r\n  SearchOptions\r\n} from './search-worker';\r\n\r\nexport interface WorkerConfig {\r\n  maxWorkers: number;\r\n  workerTimeout: number; // ms\r\n  enableDistributedSearch: boolean;\r\n  fallbackToSingleWorker: boolean;\r\n}\r\n\r\nexport interface SearchJobResult {\r\n  bestMove: Position | null;\r\n  evaluation: number;\r\n  nodes: number;\r\n  depth: number;\r\n  timeUsed: number;\r\n  workersUsed: number;\r\n  distributionStrategy: 'single' | 'distributed' | 'fallback';\r\n}\r\n\r\ninterface ActiveWorker {\r\n  worker: Worker;\r\n  busy: boolean;\r\n  jobId: string | null;\r\n  startTime: number;\r\n}\r\n\r\ninterface PendingJob {\r\n  id: string;\r\n  resolve: (result: SearchJobResult) => void;\r\n  reject: (error: Error) => void;\r\n  timeout: NodeJS.Timeout;\r\n  startTime: number;\r\n  workersAssigned: string[];\r\n  results: Map<string, SearchResponse>;\r\n  expectedResponses: number;\r\n}\r\n\r\nexport class SearchWorkerManager {\r\n  private workers: Map<string, ActiveWorker> = new Map();\r\n  private pendingJobs: Map<string, PendingJob> = new Map();\r\n  private config: WorkerConfig;\r\n  private nextJobId = 1;\r\n\r\n  constructor(config: Partial<WorkerConfig> = {}) {\r\n    this.config = {\r\n      maxWorkers: config.maxWorkers || Math.max(1, Math.floor(navigator.hardwareConcurrency / 2)),\r\n      workerTimeout: config.workerTimeout || 30000,\r\n      enableDistributedSearch: config.enableDistributedSearch ?? true,\r\n      fallbackToSingleWorker: config.fallbackToSingleWorker ?? true\r\n    };\r\n\r\n    this.initializeWorkers();\r\n  }\r\n\r\n  private initializeWorkers(): void {\n    for (let i = 0; i < this.config.maxWorkers; i++) {\n      const workerId = `worker-${i}`;\n      const worker = this.spawnWorker(workerId);\n\n      worker.onmessage = (event) => this.handleWorkerMessage(workerId, event.data);\n      worker.onerror = (error) => this.handleWorkerError(workerId, error);\n\n      this.workers.set(workerId, {\n        worker,\r\n        busy: false,\r\n        jobId: null,\r\n        startTime: 0\r\n      });\r\n    }\r\n  }\r\n\r\n  async search(\r\n    gameCore: GameCore,\r\n    player: Player,\r\n    options: SearchOptions = {}\r\n  ): Promise<SearchJobResult> {\r\n    const jobId = `job-${this.nextJobId++}`;\r\n    const startTime = performance.now();\r\n\r\n    return new Promise((resolve, reject) => {\r\n      // Set up timeout\r\n      const timeout = setTimeout(() => {\r\n        this.cancelJob(jobId);\r\n        reject(new Error(`Search timeout after ${this.config.workerTimeout}ms`));\r\n      }, options.timeLimit || this.config.workerTimeout);\r\n\r\n      // Get available moves for potential distribution\r\n      const validMoves = this.getValidMoves(gameCore, player);\r\n\r\n      // Determine search strategy\r\n      const shouldDistribute =\r\n        this.config.enableDistributedSearch &&\r\n        validMoves.length >= 4 &&\r\n        this.getAvailableWorkerCount() >= 2;\r\n\r\n      if (shouldDistribute) {\r\n        this.startDistributedSearch(jobId, gameCore, player, options, validMoves, resolve, reject, timeout, startTime);\r\n      } else {\r\n        this.startSingleWorkerSearch(jobId, gameCore, player, options, resolve, reject, timeout, startTime);\r\n      }\r\n    });\r\n  }\r\n\r\n  private startSingleWorkerSearch(\r\n    jobId: string,\r\n    gameCore: GameCore,\r\n    player: Player,\r\n    options: SearchOptions,\r\n    resolve: (result: SearchJobResult) => void,\r\n    reject: (error: Error) => void,\r\n    timeout: NodeJS.Timeout,\r\n    startTime: number\r\n  ): void {\r\n    const availableWorker = this.getAvailableWorker();\r\n\r\n    if (!availableWorker) {\r\n      clearTimeout(timeout);\r\n      reject(new Error('No workers available'));\r\n      return;\r\n    }\r\n\r\n    const [workerId, workerData] = availableWorker;\r\n\r\n    // Mark worker as busy\r\n    workerData.busy = true;\r\n    workerData.jobId = jobId;\r\n    workerData.startTime = performance.now();\r\n\r\n    // Create pending job\r\n    this.pendingJobs.set(jobId, {\r\n      id: jobId,\r\n      resolve,\r\n      reject,\r\n      timeout,\r\n      startTime,\r\n      workersAssigned: [workerId],\r\n      results: new Map(),\r\n      expectedResponses: 1\r\n    });\r\n\r\n    // Send search request\r\n    const request: SearchRequest = {\r\n      id: jobId,\r\n      gameCore,\r\n      player,\r\n      options\r\n    };\r\n\r\n    workerData.worker.postMessage(request);\r\n  }\r\n\r\n  private startDistributedSearch(\r\n    jobId: string,\r\n    gameCore: GameCore,\r\n    player: Player,\r\n    options: SearchOptions,\r\n    validMoves: Position[],\r\n    resolve: (result: SearchJobResult) => void,\r\n    reject: (error: Error) => void,\r\n    timeout: NodeJS.Timeout,\r\n    startTime: number\r\n  ): void {\r\n    const availableWorkers = this.getAvailableWorkers();\r\n    const workerCount = Math.min(availableWorkers.length, validMoves.length);\r\n\r\n    if (workerCount === 0) {\r\n      clearTimeout(timeout);\r\n      reject(new Error('No workers available for distributed search'));\r\n      return;\r\n    }\r\n\r\n    // Distribute moves among workers\r\n    const moveGroups = this.distributeMoves(validMoves, workerCount);\r\n    const workerIds: string[] = [];\r\n\r\n    // Create pending job\r\n    this.pendingJobs.set(jobId, {\r\n      id: jobId,\r\n      resolve,\r\n      reject,\r\n      timeout,\r\n      startTime,\r\n      workersAssigned: [],\r\n      results: new Map(),\r\n      expectedResponses: workerCount\r\n    });\r\n\r\n    // Assign work to each worker\r\n    for (let i = 0; i < workerCount; i++) {\r\n      const [workerId, workerData] = availableWorkers[i];\r\n      const moves = moveGroups[i];\r\n\r\n      workerData.busy = true;\r\n      workerData.jobId = jobId;\r\n      workerData.startTime = performance.now();\r\n      workerIds.push(workerId);\r\n\r\n      const request: SearchRequest = {\r\n        id: `${jobId}-${workerId}`,\r\n        gameCore,\r\n        player,\r\n        options: {\r\n          ...options,\r\n          timeLimit: options.timeLimit ? Math.floor(options.timeLimit / workerCount) : undefined\r\n        },\r\n        rootMoves: moves\r\n      };\r\n\r\n      workerData.worker.postMessage(request);\r\n    }\r\n\r\n    // Update job with assigned workers\r\n    const job = this.pendingJobs.get(jobId)!;\r\n    job.workersAssigned = workerIds;\r\n  }\r\n\r\n  private handleWorkerMessage(workerId: string, data: SearchResult): void {\r\n    const workerData = this.workers.get(workerId);\r\n    if (!workerData) return;\r\n\r\n    // Extract job ID (handle both single and distributed formats)\r\n    const jobId = data.id.includes('-') ? data.id.split('-')[0] : data.id;\r\n    const job = this.pendingJobs.get(jobId);\r\n\r\n    if (!job) {\r\n      console.warn(`Received result for unknown job: ${data.id}`);\r\n      return;\r\n    }\r\n\r\n    // Mark worker as available\r\n    workerData.busy = false;\r\n    workerData.jobId = null;\r\n\r\n    if (data.success) {\r\n      job.results.set(data.id, data);\r\n\r\n      // Check if we have all expected results\r\n      if (job.results.size >= job.expectedResponses) {\r\n        this.completeJob(jobId);\r\n      }\r\n    } else {\r\n      // Handle error\r\n      const error = new Error(data.error);\r\n      this.failJob(jobId, error);\r\n    }\r\n  }\r\n\r\n  private handleWorkerError(workerId: string, error: ErrorEvent): void {\r\n    console.error(`Worker ${workerId} error:`, error);\r\n\r\n    const workerData = this.workers.get(workerId);\r\n    if (workerData && workerData.jobId) {\r\n      const job = this.pendingJobs.get(workerData.jobId);\r\n      if (job) {\r\n        this.failJob(workerData.jobId, new Error(`Worker error: ${error.message}`));\r\n      }\r\n    }\r\n\r\n    // Restart the worker\r\n    this.restartWorker(workerId);\r\n  }\r\n\r\n  private completeJob(jobId: string): void {\r\n    const job = this.pendingJobs.get(jobId);\r\n    if (!job) return;\r\n\r\n    clearTimeout(job.timeout);\r\n\r\n    try {\r\n      // Aggregate results from all workers\r\n      const results = Array.from(job.results.values());\r\n      const best = this.selectBestResult(results);\r\n\r\n      const finalResult: SearchJobResult = {\r\n        bestMove: best.bestMove,\r\n        evaluation: best.evaluation,\r\n        nodes: results.reduce((sum, r) => sum + r.nodes, 0),\r\n        depth: Math.max(...results.map(r => r.depth)),\r\n        timeUsed: performance.now() - job.startTime,\r\n        workersUsed: results.length,\r\n        distributionStrategy: results.length > 1 ? 'distributed' : 'single'\r\n      };\r\n\r\n      job.resolve(finalResult);\r\n    } catch (error) {\r\n      job.reject(error as Error);\r\n    } finally {\r\n      this.pendingJobs.delete(jobId);\r\n    }\r\n  }\r\n\r\n  private failJob(jobId: string, error: Error): void {\r\n    const job = this.pendingJobs.get(jobId);\r\n    if (!job) return;\r\n\r\n    clearTimeout(job.timeout);\r\n\r\n    // Free up assigned workers\r\n    for (const workerId of job.workersAssigned) {\r\n      const workerData = this.workers.get(workerId);\r\n      if (workerData) {\r\n        workerData.busy = false;\r\n        workerData.jobId = null;\r\n      }\r\n    }\r\n\r\n    job.reject(error);\r\n    this.pendingJobs.delete(jobId);\r\n  }\r\n\r\n  private cancelJob(jobId: string): void {\r\n    const job = this.pendingJobs.get(jobId);\r\n    if (!job) return;\r\n\r\n    // Terminate workers assigned to this job\r\n    for (const workerId of job.workersAssigned) {\r\n      const workerData = this.workers.get(workerId);\r\n      if (workerData) {\r\n        workerData.worker.terminate();\r\n        this.restartWorker(workerId);\r\n      }\r\n    }\r\n\r\n    this.pendingJobs.delete(jobId);\r\n  }\r\n\r\n  private selectBestResult(results: SearchResponse[]): SearchResponse {\r\n    return results.reduce((best, current) =>\r\n      current.evaluation > best.evaluation ? current : best\r\n    );\r\n  }\r\n\r\n  private distributeMoves(moves: Position[], workerCount: number): Position[][] {\r\n    const groups: Position[][] = Array.from({ length: workerCount }, () => []);\r\n\r\n    // Round-robin distribution for balanced load\r\n    moves.forEach((move, index) => {\r\n      groups[index % workerCount].push(move);\r\n    });\r\n\r\n    return groups;\r\n  }\r\n\r\n  private getValidMoves(gameCore: GameCore, player: Player): Position[] {\n    // This should use your actual game logic\n    // For now, return the valid moves from the game core\n    return Array.from(gameCore.validMoves);\n  }\n\r\n  private getAvailableWorker(): [string, ActiveWorker] | null {\r\n    for (const [id, worker] of this.workers) {\r\n      if (!worker.busy) {\r\n        return [id, worker];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private getAvailableWorkers(): [string, ActiveWorker][] {\r\n    return Array.from(this.workers.entries()).filter(([_, worker]) => !worker.busy);\r\n  }\r\n\r\n  private getAvailableWorkerCount(): number {\r\n    return Array.from(this.workers.values()).filter(w => !w.busy).length;\r\n  }\r\n\r\n  private restartWorker(workerId: string): void {\n    const oldWorkerData = this.workers.get(workerId);\n    if (oldWorkerData) {\n      oldWorkerData.worker.terminate();\n    }\n\n    // Create new worker\n    const worker = this.spawnWorker(workerId);\n\n    worker.onmessage = (event) => this.handleWorkerMessage(workerId, event.data);\n    worker.onerror = (error) => this.handleWorkerError(workerId, error);\n\n    this.workers.set(workerId, {\n      worker,\r\n      busy: false,\r\n      jobId: null,\r\n      startTime: 0\r\n    });\r\n  }\n\n  private spawnWorker(workerId: string): Worker {\n    const workerUrl = new URL('./search-worker.ts', import.meta.url);\n    return new Worker(workerUrl, {\n      type: 'module',\n      name: workerId\n    });\n  }\n\r\n  // Public methods\r\n  getStatus() {\r\n    const workers = Array.from(this.workers.values());\r\n    return {\r\n      totalWorkers: workers.length,\r\n      busyWorkers: workers.filter(w => w.busy).length,\r\n      availableWorkers: workers.filter(w => !w.busy).length,\r\n      pendingJobs: this.pendingJobs.size,\r\n      config: this.config\r\n    };\r\n  }\r\n\r\n  async terminate(): Promise<void> {\r\n    // Cancel all pending jobs\r\n    for (const jobId of this.pendingJobs.keys()) {\r\n      this.cancelJob(jobId);\r\n    }\r\n\r\n    // Terminate all workers\r\n    const terminationPromises = Array.from(this.workers.values()).map(\r\n      workerData => {\r\n        return new Promise<void>(resolve => {\r\n          workerData.worker.onmessage = null;\r\n          workerData.worker.onerror = null;\r\n          workerData.worker.terminate();\r\n          resolve();\r\n        });\r\n      }\r\n    );\r\n\r\n    await Promise.all(terminationPromises);\r\n\r\n    this.workers.clear();\r\n    this.pendingJobs.clear();\r\n  }\r\n}\n", "// High-performance bitboard operations\r\nexport * from \"./bitboard\";\r\n\r\n// Complete game logic with type adapters\r\nexport * from \"./gameCore\";\r\n\r\n// Game state management with undo/redo\r\nexport * from \"./GameStateManager\";\r\nexport { GameStateManager } from \"./GameStateManager\";\r\n\r\n// Multi-worker AI search system\r\nexport * from \"./SearchWorkerManager\";\r\nexport { SearchWorkerManager } from \"./SearchWorkerManager\";\r\n\r\n", "// Transposition Table implementation with aging\r\n// Converted from search-neo.js makeTT function\r\n\r\nimport type { Position } from 'shared-types';\r\n\r\nexport enum TTFlag {\r\n  EXACT = 0,  // Exact score\r\n  LOWER = 1,  // Lower bound (fail-high)\r\n  UPPER = 2   // Upper bound (fail-low)\r\n}\r\n\r\nexport interface TTEntry {\n  depth: number;\n  flag: TTFlag;\n  score: number;\n  bestMove?: Position;\n  age: number;\n}\n\r\n/**\r\n * Transposition Table with aging eviction policy\r\n */\r\nexport class TranspositionTable {\r\n  private table = new Map<string, TTEntry>();\r\n  private currentAge = 0;\r\n  private readonly maxSize: number;\r\n\r\n  constructor(maxSize: number = 200000) {\r\n    this.maxSize = maxSize;\r\n  }\r\n\r\n  /**\r\n   * Get current age\r\n   */\r\n  getAge(): number {\r\n    return this.currentAge;\r\n  }\r\n\r\n  /**\r\n   * Increment age (called at start of each search)\r\n   */\r\n  bumpAge(): void {\r\n    this.currentAge = (this.currentAge + 1) | 0;\r\n  }\r\n\r\n  /**\r\n   * Get entry from table\r\n   */\r\n  get(key: string): TTEntry | undefined {\r\n    return this.table.get(key);\r\n  }\r\n\r\n  /**\r\n   * Store entry in table with eviction if needed\r\n   */\r\n  set(key: string, entry: TTEntry): void {\r\n    // Check if table is full\r\n    if (this.table.size >= this.maxSize) {\r\n      this.evictOldEntries();\r\n    }\r\n\r\n    // Set the entry with current age\r\n    this.table.set(key, { ...entry, age: this.currentAge });\r\n  }\r\n\r\n  /**\r\n   * Evict old entries when table is full\r\n   */\r\n  private evictOldEntries(): void {\r\n    // Remove ~2% of oldest entries\r\n    const evictionCount = Math.max(1, Math.floor(this.maxSize * 0.02));\r\n    let removed = 0;\r\n\r\n    // First pass: remove entries from previous ages\r\n    for (const [key, entry] of this.table.entries()) {\r\n      if (entry.age !== this.currentAge) {\r\n        this.table.delete(key);\r\n        removed++;\r\n        if (removed >= evictionCount) break;\r\n      }\r\n    }\r\n\r\n    // If we still need more space, remove some current age entries\r\n    if (this.table.size >= this.maxSize) {\r\n      let fallbackRemoved = 0;\r\n      const fallbackLimit = 64;\r\n\r\n      for (const key of this.table.keys()) {\r\n        this.table.delete(key);\r\n        fallbackRemoved++;\r\n        if (fallbackRemoved >= fallbackLimit) break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear the entire table\r\n   */\r\n  clear(): void {\r\n    this.table.clear();\r\n    this.currentAge = 0;\r\n  }\r\n\r\n  /**\r\n   * Get table statistics\r\n   */\r\n  getStats(): {\r\n    size: number;\r\n    maxSize: number;\r\n    age: number;\r\n    fillRatio: number;\r\n  } {\r\n    return {\r\n      size: this.table.size,\r\n      maxSize: this.maxSize,\r\n      age: this.currentAge,\r\n      fillRatio: this.table.size / this.maxSize,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if entry is usable for given depth\r\n   */\r\n  isUsable(entry: TTEntry | undefined, depth: number): boolean {\r\n    return entry !== undefined && entry.depth >= depth;\r\n  }\r\n\r\n  /**\r\n   * Extract best move from entry\r\n   */\r\n  getBestMove(entry: TTEntry | undefined): Position | undefined {\n    return entry?.bestMove;\n  }\n\r\n  /**\r\n   * Check if entry provides cutoff for alpha-beta bounds\r\n   */\r\n  providesScoreCutoff(\r\n    entry: TTEntry,\r\n    alpha: number,\r\n    beta: number,\r\n    depth: number\r\n  ): { cutoff: boolean; score?: number; newAlpha?: number; newBeta?: number } {\r\n    if (!this.isUsable(entry, depth)) {\r\n      return { cutoff: false };\r\n    }\r\n\r\n    const { flag, score } = entry;\r\n\r\n    // Exact score\r\n    if (flag === TTFlag.EXACT) {\r\n      return { cutoff: true, score };\r\n    }\r\n\r\n    // Lower bound (fail-high)\r\n    if (flag === TTFlag.LOWER && score >= beta) {\r\n      return { cutoff: true, score };\r\n    }\r\n\r\n    // Upper bound (fail-low)\r\n    if (flag === TTFlag.UPPER && score <= alpha) {\r\n      return { cutoff: true, score };\r\n    }\r\n\r\n    // Window tightening\r\n    let newAlpha = alpha;\r\n    let newBeta = beta;\r\n\r\n    if (flag === TTFlag.LOWER) {\r\n      newAlpha = Math.max(alpha, score);\r\n    } else if (flag === TTFlag.UPPER) {\r\n      newBeta = Math.min(beta, score);\r\n    }\r\n\r\n    // Check for window closure\r\n    if (newAlpha >= newBeta) {\r\n      return { cutoff: true, score };\r\n    }\r\n\r\n    return {\r\n      cutoff: false,\r\n      newAlpha: newAlpha !== alpha ? newAlpha : undefined,\r\n      newBeta: newBeta !== beta ? newBeta : undefined\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create TT entry for storage\r\n   */\r\n  createEntry(\r\n    depth: number,\r\n    score: number,\r\n    bestMove: Position | undefined,\n    alpha: number,\n    beta: number\n  ): TTEntry {\n    let flag: TTFlag;\r\n\r\n    if (score <= alpha) {\r\n      flag = TTFlag.UPPER;\r\n    } else if (score >= beta) {\r\n      flag = TTFlag.LOWER;\r\n    } else {\r\n      flag = TTFlag.EXACT;\r\n    }\r\n\r\n    return {\r\n      depth,\r\n      flag,\r\n      score,\r\n      bestMove,\r\n      age: this.currentAge,\r\n    };\r\n  }\r\n}\n", "// Dynamic weights system based on game phase\r\n// Converted from ai.js dynamicWeights function\r\n\r\nexport interface EvaluationWeights {\r\n  mobility: number;        // Current move count advantage\r\n  pmob: number;           // Potential mobility (empty squares adjacent to opponent)\r\n  stability: number;      // Stable discs that cannot be flipped\r\n  frontier: number;       // Frontier discs (adjacent to empty squares)\r\n  corner: number;         // Corner control\r\n  x: number;             // X-square penalty (diagonal to corners)\r\n  c: number;             // C-square penalty (adjacent to corners)\r\n  parity: number;         // Move parity advantage\r\n  edge: number;          // Edge stability\r\n  edgeOcc: number;       // Edge occupancy\r\n}\r\n\r\n/**\r\n * Get evaluation weights based on empty squares remaining\r\n * Dynamically adjusts strategy based on game phase\r\n */\r\nexport function getEvaluationWeights(empties: number): EvaluationWeights {\r\n  // Early game (45+ empties): Focus on mobility and position\r\n  if (empties >= 45) {\r\n    return {\r\n      mobility: 28,\r\n      pmob: 12,\r\n      stability: 6,\r\n      frontier: 10,\r\n      corner: 35,\r\n      x: 18,\r\n      c: 10,\r\n      parity: 0,\r\n      edge: 4,\r\n      edgeOcc: -4,\r\n    };\r\n  }\r\n\r\n  // Mid game (20-44 empties): Balanced approach\r\n  if (empties >= 20) {\r\n    return {\r\n      mobility: 24,\r\n      pmob: 16,\r\n      stability: 10,\r\n      frontier: 16,\r\n      corner: 34,\r\n      x: 22,\r\n      c: 14,\r\n      parity: 6,\r\n      edge: 8,\r\n      edgeOcc: -8,\r\n    };\r\n  }\r\n\r\n  // End game (<20 empties): Prioritize stability and parity\r\n  return {\r\n    mobility: 8,\r\n    pmob: 6,\r\n    stability: 22,\r\n    frontier: 8,\r\n    corner: 40,\r\n    x: 20,\r\n    c: 12,\r\n    parity: 18,\r\n    edge: 12,\r\n    edgeOcc: 6,\r\n  };\r\n}\r\n\r\n/**\r\n * Static positional evaluation table\r\n * Higher values indicate better positions\r\n */\r\nexport const POSITIONAL_WEIGHTS = [\r\n  [120, -20, 20, 5, 5, 20, -20, 120],\r\n  [-20, -40, -5, -5, -5, -5, -40, -20],\r\n  [20, -5, 15, 3, 3, 15, -5, 20],\r\n  [5, -5, 3, 3, 3, 3, -5, 5],\r\n  [5, -5, 3, 3, 3, 3, -5, 5],\r\n  [20, -5, 15, 3, 3, 15, -5, 20],\r\n  [-20, -40, -5, -5, -5, -5, -40, -20],\r\n  [120, -20, 20, 5, 5, 20, -20, 120],\r\n] as const;\r\n\r\n/**\r\n * Corner data for X-square and C-square analysis\r\n */\r\nexport const CORNER_DATA = [\r\n  {\r\n    corner: [0, 0] as const,\r\n    x: [1, 1] as const,\r\n    c: [[0, 1], [1, 0]] as const,\r\n  },\r\n  {\r\n    corner: [0, 7] as const,\r\n    x: [1, 6] as const,\r\n    c: [[0, 6], [1, 7]] as const,\r\n  },\r\n  {\r\n    corner: [7, 0] as const,\r\n    x: [6, 1] as const,\r\n    c: [[6, 0], [7, 1]] as const,\r\n  },\r\n  {\r\n    corner: [7, 7] as const,\r\n    x: [6, 6] as const,\r\n    c: [[6, 7], [7, 6]] as const,\r\n  },\r\n] as const;\r\n\r\n/**\r\n * Directions for neighbor checking (8-directional)\r\n */\r\nexport const DIRECTIONS = [\r\n  [-1, -1], [-1, 0], [-1, 1],\r\n  [0, -1],           [0, 1],\r\n  [1, -1],  [1, 0],  [1, 1]\r\n] as const;", "// Mobility analysis functions\r\n// Converted from ai.js mobility and potential mobility calculations\r\n\r\nimport type { Board, Player, Position } from 'shared-types';\r\nimport { getValidMoves } from 'core';\r\nimport { DIRECTIONS } from './weights';\r\n\r\n/**\r\n * Count current valid moves for a player\r\n * Uses the optimized bitboard-based getValidMoves from core\r\n */\r\nexport function getCurrentMobility(board: Board, player: Player): number {\r\n  return getValidMoves(board, player).length;\r\n}\r\n\r\n/**\r\n * Count potential mobility - empty squares adjacent to opponent discs\r\n * Represents potential future mobility as the game develops\r\n */\r\nexport function getPotentialMobility(board: Board, player: Player): number {\r\n  const opponent: Player = player === 'black' ? 'white' : 'black';\r\n  let count = 0;\r\n\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      // Only consider empty squares\r\n      if (board[r][c] !== null) continue;\r\n\r\n      // Check if this empty square is adjacent to opponent disc\r\n      let adjacentToOpponent = false;\r\n      for (const [dr, dc] of DIRECTIONS) {\r\n        const nr = r + dr;\r\n        const nc = c + dc;\r\n\r\n        if (\r\n          nr >= 0 && nr < 8 &&\r\n          nc >= 0 && nc < 8 &&\r\n          board[nr][nc] === opponent\r\n        ) {\r\n          adjacentToOpponent = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (adjacentToOpponent) count++;\r\n    }\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Analyze mobility difference between players\r\n * Returns positive value if current player has mobility advantage\r\n */\r\nexport function getMobilityAdvantage(\r\n  board: Board,\r\n  player: Player,\r\n  opponent: Player\r\n): {\r\n  currentMobility: number;\r\n  potentialMobility: number;\r\n  mobilityDiff: number;\r\n  potentialMobilityDiff: number;\r\n} {\r\n  const currentPlayer = getCurrentMobility(board, player);\r\n  const currentOpponent = getCurrentMobility(board, opponent);\r\n  const potentialPlayer = getPotentialMobility(board, player);\r\n  const potentialOpponent = getPotentialMobility(board, opponent);\r\n\r\n  return {\r\n    currentMobility: currentPlayer,\r\n    potentialMobility: potentialPlayer,\r\n    mobilityDiff: currentPlayer - currentOpponent,\r\n    potentialMobilityDiff: potentialPlayer - potentialOpponent,\r\n  };\r\n}\r\n\r\n/**\r\n * Check if a position is strategically important (corner)\r\n * Used for move prioritization\r\n */\r\nexport function isImportantMove(position: Position): boolean {\r\n  const { row, col } = position;\r\n  return (\r\n    (row === 0 || row === 7) &&\r\n    (col === 0 || col === 7)\r\n  );\r\n}\r\n\r\n/**\r\n * Count empty squares on the board\r\n * Used for game phase detection\r\n */\r\nexport function countEmptySquares(board: Board): number {\r\n  let count = 0;\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      if (board[r][c] === null) count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * Calculate disc count for both players\r\n */\r\nexport function calculateDiscCounts(board: Board): { black: number; white: number } {\r\n  let black = 0;\r\n  let white = 0;\r\n\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      const cell = board[r][c];\r\n      if (cell === 'black') black++;\r\n      else if (cell === 'white') white++;\r\n    }\r\n  }\r\n\r\n  return { black, white };\r\n}", "// Move ordering system for search optimization\r\n// Converted from ai.js and search-neo.js move ordering logic\r\n\r\nimport type { Position, Player, Board } from 'shared-types';\r\nimport { POSITIONAL_WEIGHTS } from '../evaluation/weights';\r\nimport { isImportantMove } from '../evaluation/mobility';\r\n\r\n/**\r\n * Killer moves storage - stores best moves that caused cutoffs\r\n */\r\nexport class KillerMoves {\r\n  private moves: Map<number, Position[]> = new Map();\r\n  private readonly maxKillersPerPly = 2;\r\n\r\n  /**\r\n   * Add a killer move for a specific ply\r\n   */\r\n  addKiller(ply: number, move: Position): void {\r\n    if (!this.moves.has(ply)) {\r\n      this.moves.set(ply, []);\r\n    }\r\n\r\n    const killers = this.moves.get(ply)!;\r\n\r\n    // Remove if already exists\r\n    const index = killers.findIndex(k => k.row === move.row && k.col === move.col);\r\n    if (index !== -1) {\r\n      killers.splice(index, 1);\r\n    }\r\n\r\n    // Add to front\r\n    killers.unshift(move);\r\n\r\n    // Keep only max killers\r\n    if (killers.length > this.maxKillersPerPly) {\r\n      killers.pop();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get killer moves for a specific ply\r\n   */\r\n  getKillers(ply: number): Position[] {\r\n    return this.moves.get(ply) || [];\r\n  }\r\n\r\n  /**\r\n   * Get priority of a move based on killer heuristic\r\n   */\r\n  getKillerPriority(move: Position, ply: number): number {\r\n    const killers = this.getKillers(ply);\r\n\r\n    for (let i = 0; i < killers.length; i++) {\r\n      const killer = killers[i];\r\n      if (killer.row === move.row && killer.col === move.col) {\r\n        return 2 - i; // First killer gets priority 2, second gets 1\r\n      }\r\n    }\r\n\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Clear killer moves (called between searches)\r\n   */\r\n  clear(): void {\r\n    this.moves.clear();\r\n  }\r\n}\r\n\r\n/**\r\n * History heuristic - tracks successful moves\r\n */\r\nexport class HistoryTable {\r\n  private history: Map<string, number> = new Map();\r\n\r\n  /**\r\n   * Generate key for move and player\r\n   */\r\n  private getKey(move: Position, player: Player): string {\r\n    return `${move.row},${move.col}|${player}`;\r\n  }\r\n\r\n  /**\r\n   * Update history score for a move\r\n   */\r\n  updateHistory(move: Position, player: Player, depth: number): void {\r\n    const key = this.getKey(move, player);\r\n    const bonus = depth * depth; // Deeper searches get higher bonus\r\n    const current = this.history.get(key) || 0;\r\n    this.history.set(key, current + bonus);\r\n  }\r\n\r\n  /**\r\n   * Get history score for a move\r\n   */\r\n  getHistoryScore(move: Position, player: Player): number {\r\n    const key = this.getKey(move, player);\r\n    return this.history.get(key) || 0;\r\n  }\r\n\r\n  /**\r\n   * Clear history table\r\n   */\r\n  clear(): void {\r\n    this.history.clear();\r\n  }\r\n\r\n  /**\r\n   * Age history scores (reduce by factor to prioritize recent moves)\r\n   */\r\n  ageHistory(factor: number = 0.9): void {\r\n    for (const [key, score] of this.history.entries()) {\r\n      this.history.set(key, Math.floor(score * factor));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Move ordering context\r\n */\r\nexport interface MoveOrderingContext {\r\n  ply: number;\r\n  player: Player;\r\n  board: Board;\r\n  killers: KillerMoves;\r\n  history: HistoryTable;\r\n  ttBestMove?: Position; // Best move from transposition table\r\n}\r\n\r\n/**\r\n * Scored move for sorting\r\n */\r\ninterface ScoredMove {\r\n  move: Position;\r\n  score: number;\r\n}\r\n\r\n/**\r\n * Order moves for optimal search performance\r\n * Better moves should be searched first for alpha-beta pruning efficiency\r\n */\r\nexport function orderMoves(\r\n  moves: Position[],\r\n  context: MoveOrderingContext\r\n): Position[] {\r\n  const { ply, player, board, killers, history, ttBestMove } = context;\r\n\r\n  const scoredMoves: ScoredMove[] = moves.map(move => ({\r\n    move,\r\n    score: scoreMoveForOrdering(move, context)\r\n  }));\r\n\r\n  // Sort by score (higher is better)\r\n  scoredMoves.sort((a, b) => b.score - a.score);\r\n\r\n  return scoredMoves.map(sm => sm.move);\r\n}\r\n\r\n/**\r\n * Score a single move for ordering purposes\r\n */\r\nfunction scoreMoveForOrdering(\r\n  move: Position,\r\n  context: MoveOrderingContext\r\n): number {\r\n  const { ply, player, killers, history, ttBestMove } = context;\r\n  let score = 0;\r\n\r\n  // 1. Transposition table best move gets highest priority\r\n  if (ttBestMove &&\r\n      ttBestMove.row === move.row &&\r\n      ttBestMove.col === move.col) {\r\n    score += 10000;\r\n  }\r\n\r\n  // 2. Corner moves are extremely valuable\r\n  if (isImportantMove(move)) {\r\n    score += 5000;\r\n  }\r\n\r\n  // 3. Positional value from evaluation table\r\n  score += POSITIONAL_WEIGHTS[move.row][move.col];\r\n\r\n  // 4. Killer move bonus\r\n  const killerPriority = killers.getKillerPriority(move, ply);\r\n  if (killerPriority > 0) {\r\n    score += 1000 * killerPriority;\r\n  }\r\n\r\n  // 5. History heuristic bonus\r\n  const historyScore = history.getHistoryScore(move, player);\r\n  score += historyScore / 10; // Scale down history score\r\n\r\n  // 6. Center preference (mild bonus for central squares)\r\n  const centerDistance = Math.abs(move.row - 3.5) + Math.abs(move.col - 3.5);\r\n  score += (7 - centerDistance) * 2;\r\n\r\n  return score;\r\n}\r\n\r\n/**\r\n * Filter moves for quiescence search (tactical moves only)\r\n */\r\nexport function filterTacticalMoves(\r\n  moves: Position[],\r\n  board: Board,\r\n  player: Player\r\n): Position[] {\r\n  const tactical: Position[] = [];\r\n\r\n  for (const move of moves) {\r\n    // Always include corner moves\r\n    if (isImportantMove(move)) {\r\n      tactical.push(move);\r\n      continue;\r\n    }\r\n\r\n    // Include high-value positional moves\r\n    const positionalValue = POSITIONAL_WEIGHTS[move.row][move.col];\r\n    if (positionalValue >= 15) {\r\n      tactical.push(move);\r\n    }\r\n  }\r\n\r\n  // Limit to reasonable number for quiescence\r\n  return tactical.slice(0, 8);\r\n}\r\n\r\n/**\r\n * Move ordering configuration\r\n */\r\nexport interface MoveOrderingConfig {\r\n  useKillerHeuristic: boolean;\r\n  useHistoryHeuristic: boolean;\r\n  maxHistoryAge: number;\r\n  historyAgingFactor: number;\r\n}\r\n\r\nexport const DEFAULT_ORDERING_CONFIG: MoveOrderingConfig = {\r\n  useKillerHeuristic: true,\r\n  useHistoryHeuristic: true,\r\n  maxHistoryAge: 10000,\r\n  historyAgingFactor: 0.95,\r\n};", "// Stability analysis functions\r\n// Converted from ai.js countStableDiscs and countEdgeStableDiscs\r\n\r\nimport type { Board, Player } from 'shared-types';\r\nimport { DIRECTIONS } from './weights';\r\n\r\n/**\r\n * Count stable discs that cannot be flipped\r\n * Focuses on corner-based stability\r\n */\r\nexport function countStableDiscs(board: Board, player: Player): number {\r\n  const stable = new Set<string>();\r\n  const playerValue = player === 'black' ? 1 : 2;\r\n\r\n  // Corner positions and their expansion directions\r\n  const corners = [\r\n    {\r\n      pos: [0, 0] as const,\r\n      dirs: [[0, 1], [1, 0]] as const,\r\n    },\r\n    {\r\n      pos: [0, 7] as const,\r\n      dirs: [[0, -1], [1, 0]] as const,\r\n    },\r\n    {\r\n      pos: [7, 0] as const,\r\n      dirs: [[-1, 0], [0, 1]] as const,\r\n    },\r\n    {\r\n      pos: [7, 7] as const,\r\n      dirs: [[-1, 0], [0, -1]] as const,\r\n    },\r\n  ];\r\n\r\n  // Check each corner\r\n  for (const { pos: [r, c], dirs } of corners) {\r\n    const cell = board[r][c];\r\n    if (cell !== player) continue;\r\n\r\n    // Corner is stable\r\n    stable.add(`${r},${c}`);\r\n\r\n    // Expand stability along edges from corner\r\n    for (const [dr, dc] of dirs) {\r\n      let nr = r + dr;\r\n      let nc = c + dc;\r\n\r\n      // Continue while we find our pieces\r\n      while (\r\n        nr >= 0 && nr < 8 &&\r\n        nc >= 0 && nc < 8 &&\r\n        board[nr][nc] === player\r\n      ) {\r\n        stable.add(`${nr},${nc}`);\r\n        nr += dr;\r\n        nc += dc;\r\n      }\r\n    }\r\n  }\r\n\r\n  return stable.size;\r\n}\r\n\r\n/**\r\n * Count edge-stable discs from corners\r\n * More refined stability analysis for edge positions\r\n */\r\nexport function countEdgeStableDiscs(board: Board, player: Player): number {\r\n  const stable = new Set<string>();\r\n\r\n  function traverse(r: number, c: number, dr: number, dc: number) {\r\n    while (\r\n      r >= 0 && r < 8 &&\r\n      c >= 0 && c < 8 &&\r\n      board[r][c] === player\r\n    ) {\r\n      stable.add(`${r},${c}`);\r\n      r += dr;\r\n      c += dc;\r\n    }\r\n  }\r\n\r\n  // Check corners and expand along edges\r\n  const corners = [[0, 0], [0, 7], [7, 0], [7, 7]] as const;\r\n\r\n  for (const [r, c] of corners) {\r\n    if (board[r][c] !== player) continue;\r\n\r\n    // Expand from each corner along its edges\r\n    if (r === 0 && c === 0) {\r\n      traverse(r, c, 0, 1);  // East\r\n      traverse(r, c, 1, 0);  // South\r\n    } else if (r === 0 && c === 7) {\r\n      traverse(r, c, 0, -1); // West\r\n      traverse(r, c, 1, 0);  // South\r\n    } else if (r === 7 && c === 0) {\r\n      traverse(r, c, -1, 0); // North\r\n      traverse(r, c, 0, 1);  // East\r\n    } else if (r === 7 && c === 7) {\r\n      traverse(r, c, -1, 0); // North\r\n      traverse(r, c, 0, -1); // West\r\n    }\r\n  }\r\n\r\n  return stable.size;\r\n}\r\n\r\n/**\r\n * Count discs on the board edges (regardless of stability)\r\n * Used for late-game edge control evaluation\r\n */\r\nexport function countEdgeDiscs(board: Board, player: Player): number {\r\n  let count = 0;\r\n\r\n  // Top and bottom edges\r\n  for (let c = 0; c < 8; c++) {\r\n    if (board[0][c] === player) count++;\r\n    if (board[7][c] === player) count++;\r\n  }\r\n\r\n  // Left and right edges (excluding corners already counted)\r\n  for (let r = 1; r < 7; r++) {\r\n    if (board[r][0] === player) count++;\r\n    if (board[r][7] === player) count++;\r\n  }\r\n\r\n  return count;\r\n}\r\n\r\n/**\r\n * Count frontier discs (discs adjacent to at least one empty square)\r\n * Frontier discs are vulnerable as they can potentially be flanked\r\n */\r\nexport function countFrontierDiscs(board: Board, player: Player): number {\r\n  let count = 0;\r\n\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      if (board[r][c] !== player) continue;\r\n\r\n      // Check if adjacent to any empty square\r\n      let isFrontier = false;\r\n      for (const [dr, dc] of DIRECTIONS) {\r\n        const nr = r + dr;\r\n        const nc = c + dc;\r\n\r\n        if (\r\n          nr < 0 || nr >= 8 ||\r\n          nc < 0 || nc >= 8 ||\r\n          board[nr][nc] === null\r\n        ) {\r\n          isFrontier = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (isFrontier) count++;\r\n    }\r\n  }\r\n\r\n  return count;\r\n}", "// Main heuristic evaluation function\r\n// Converted and optimized from ai.js heuristicEvaluate\r\n\r\nimport type { Board, Player } from 'shared-types';\r\nimport { getEvaluationWeights, POSITIONAL_WEIGHTS, CORNER_DATA } from './weights';\r\nimport {\r\n  countStableDiscs,\r\n  countEdgeStableDiscs,\r\n  countEdgeDiscs,\r\n  countFrontierDiscs\r\n} from './stability';\r\nimport {\r\n  getMobilityAdvantage,\r\n  countEmptySquares,\r\n  calculateDiscCounts,\r\n  getPotentialMobility\r\n} from './mobility';\r\n\r\n/**\r\n * Comprehensive heuristic board evaluation\r\n * Combines multiple strategic factors with dynamic weighting\r\n */\r\nexport function evaluateBoard(\r\n  board: Board,\r\n  player: Player,\r\n  isEndgame: boolean = false\r\n): number {\r\n  // In endgame, just count discs\r\n  if (isEndgame) {\r\n    const counts = calculateDiscCounts(board);\r\n    const playerCount = counts[player];\r\n    const opponentCount = player === 'black' ? counts.white : counts.black;\r\n    return playerCount - opponentCount;\r\n  }\r\n\r\n  const opponent: Player = player === 'black' ? 'white' : 'black';\r\n  const empties = countEmptySquares(board);\r\n  const weights = getEvaluationWeights(empties);\r\n\r\n  let totalScore = 0;\r\n\r\n  // 1. Positional Score (piece-square table)\r\n  let positionalScore = 0;\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      const cell = board[r][c];\r\n      if (cell === player) {\r\n        positionalScore += POSITIONAL_WEIGHTS[r][c];\r\n      } else if (cell === opponent) {\r\n        positionalScore -= POSITIONAL_WEIGHTS[r][c];\r\n      }\r\n    }\r\n  }\r\n\r\n  // 2. Mobility Scores\r\n  const mobility = getMobilityAdvantage(board, player, opponent);\r\n  const mobilityScore = weights.mobility * mobility.mobilityDiff;\r\n  const potentialMobilityScore = weights.pmob * mobility.potentialMobilityDiff;\r\n\r\n  // 3. Stability Scores\r\n  const playerStable = countStableDiscs(board, player);\r\n  const opponentStable = countStableDiscs(board, opponent);\r\n  const stabilityScore = weights.stability * (playerStable - opponentStable);\r\n\r\n  // 4. Frontier Score (fewer frontier discs is better)\r\n  const playerFrontier = countFrontierDiscs(board, player);\r\n  const opponentFrontier = countFrontierDiscs(board, opponent);\r\n  const frontierScore = weights.frontier * (opponentFrontier - playerFrontier);\r\n\r\n  // 5. Parity Score (who makes the last move)\r\n  const parityScore = (empties % 2 === (player === 'black' ? 1 : 0))\r\n    ? weights.parity\r\n    : -weights.parity;\r\n\r\n  // 6. Edge Stability Score\r\n  const playerEdgeStable = countEdgeStableDiscs(board, player);\r\n  const opponentEdgeStable = countEdgeStableDiscs(board, opponent);\r\n  const edgeStabilityScore = weights.edge * (playerEdgeStable - opponentEdgeStable);\r\n\r\n  // 7. Edge Occupancy Score\r\n  const playerEdgeOcc = countEdgeDiscs(board, player);\r\n  const opponentEdgeOcc = countEdgeDiscs(board, opponent);\r\n  const edgeOccScore = weights.edgeOcc * (playerEdgeOcc - opponentEdgeOcc);\r\n\r\n  // 8. Corner, X-square, and C-square Analysis\r\n  let cornerScore = 0;\r\n  let xSquareScore = 0;\r\n  let cSquareScore = 0;\r\n\r\n  for (const { corner, x, c } of CORNER_DATA) {\r\n    const [cr, cc] = corner;\r\n    const [xr, xc] = x;\r\n\r\n    const cornerCell = board[cr][cc];\r\n\r\n    if (cornerCell === player) {\r\n      cornerScore += weights.corner;\r\n    } else if (cornerCell === opponent) {\r\n      cornerScore -= weights.corner;\r\n    } else {\r\n      // Corner is empty - penalize adjacent dangerous squares\r\n      const xCell = board[xr][xc];\r\n      if (xCell === player) {\r\n        xSquareScore -= weights.x;\r\n      } else if (xCell === opponent) {\r\n        xSquareScore += weights.x;\r\n      }\r\n\r\n      // Check C-squares (adjacent to corner)\r\n      for (const [pr, pc] of c) {\r\n        const cCell = board[pr][pc];\r\n        if (cCell === player) {\r\n          cSquareScore -= weights.c;\r\n        } else if (cCell === opponent) {\r\n          cSquareScore += weights.c;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Combine all scores\r\n  totalScore =\r\n    positionalScore +\r\n    mobilityScore +\r\n    potentialMobilityScore +\r\n    stabilityScore +\r\n    frontierScore +\r\n    parityScore +\r\n    edgeStabilityScore +\r\n    edgeOccScore +\r\n    cornerScore +\r\n    xSquareScore +\r\n    cSquareScore;\r\n\r\n  return totalScore;\r\n}\r\n\r\n/**\r\n * Quick evaluation for move ordering\r\n * Uses simplified metrics for faster computation\r\n */\r\nexport function quickEvaluate(board: Board, player: Player): number {\r\n  const opponent: Player = player === 'black' ? 'white' : 'black';\r\n\r\n  let score = 0;\r\n\r\n  // Simple positional score\r\n  for (let r = 0; r < 8; r++) {\r\n    for (let c = 0; c < 8; c++) {\r\n      const cell = board[r][c];\r\n      if (cell === player) {\r\n        score += POSITIONAL_WEIGHTS[r][c];\r\n      } else if (cell === opponent) {\r\n        score -= POSITIONAL_WEIGHTS[r][c];\r\n      }\r\n    }\r\n  }\r\n\r\n  // Quick corner check\r\n  const corners = [[0, 0], [0, 7], [7, 0], [7, 7]] as const;\r\n  for (const [r, c] of corners) {\r\n    const cell = board[r][c];\r\n    if (cell === player) score += 100;\r\n    else if (cell === opponent) score -= 100;\r\n  }\r\n\r\n  return score;\r\n}\r\n\r\n/**\r\n * Check if game is in endgame phase\r\n */\r\nexport function isEndgamePhase(board: Board, threshold: number = 12): boolean {\r\n  return countEmptySquares(board) <= threshold;\r\n}", "// Principal Variation Search (PVS) implementation\r\n// Converted from search-neo.js PVS algorithm\r\n\r\nimport type { Board, Player, Position, GameCore } from \"shared-types\";\r\nimport {\r\n  TranspositionTable,\r\n  TTFlag,\r\n  type TTEntry,\r\n} from \"../optimization/transTable\";\r\nimport {\r\n  KillerMoves,\r\n  HistoryTable,\r\n  orderMoves,\r\n  type MoveOrderingContext,\r\n} from \"../ordering/moveOrdering\";\r\nimport { evaluateBoard, isEndgamePhase } from \"../evaluation/heuristic\";\r\nimport { getCurrentMobility } from \"../evaluation/mobility\";\r\nimport { getValidMoves, makeMove as coreMakeMove } from \"core\";\r\nimport {\r\n  getLevelConfig,\r\n  getSelectivitySettings,\r\n  STABILITY_THRESHOLDS,\r\n  PRUNING_PARAMS,\r\n} from \"../config/selectivity\";\r\n\r\nexport interface SearchResult {\r\n  bestMove?: Position;\r\n  score: number;\r\n  depth: number;\r\n  nodes: number;\r\n  time: number;\r\n  pv: Position[];\r\n  ttHits: number;\r\n  ttStores: number;\r\n}\r\n\r\nexport interface SearchConfig {\r\n  level: number;\r\n  timeLimit?: number;\r\n  depthLimit?: number;\r\n  enableTT: boolean;\r\n  enableKillers: boolean;\r\n  enableHistory: boolean;\r\n}\r\n\r\n/**\r\n * Principal Variation Search Engine\r\n */\r\nexport class PVSEngine {\r\n  private tt: TranspositionTable;\r\n  private killers: KillerMoves;\r\n  private history: HistoryTable;\r\n  private nodes = 0;\r\n  private quiescenceVisited = new Set<string>();\r\n  private ttHits = 0;\r\n  private ttStores = 0;\r\n  private startTime = 0;\r\n  private timeLimit = Infinity;\r\n\r\n  constructor() {\r\n    this.tt = new TranspositionTable(200000);\r\n    this.killers = new KillerMoves();\r\n    this.history = new HistoryTable();\r\n  }\r\n\r\n  /**\r\n   * Main search entry point\r\n   */\r\n  search(board: Board, player: Player, config: SearchConfig): SearchResult {\r\n    this.initializeSearch(config);\r\n\r\n    const empties = this.countEmptySquares(board);\r\n    const levelConfig = getLevelConfig(config.level, empties);\r\n    const selectivitySettings = getSelectivitySettings(levelConfig.selectivity);\r\n\r\n    let bestMove: Position | undefined;\r\n    let bestScore = -Infinity;\r\n    let pv: Position[] = [];\r\n\r\n    // Iterative deepening\r\n    for (let depth = 1; depth <= levelConfig.depth; depth++) {\r\n      if (this.shouldStop()) break;\r\n\r\n      const result = this.pvs(\r\n        board,\r\n        player,\r\n        depth,\r\n        -Infinity,\r\n        Infinity,\r\n        0,\r\n        true,\r\n        selectivitySettings,\r\n      );\r\n\r\n      if (!this.shouldStop()) {\r\n        bestMove = result.move;\r\n        bestScore = result.score;\r\n        pv = result.pv;\r\n      }\r\n    }\r\n\r\n    return {\r\n      bestMove,\r\n      score: bestScore,\r\n      depth: levelConfig.depth,\r\n      nodes: this.nodes,\r\n      time: Date.now() - this.startTime,\r\n      pv,\r\n      ttHits: this.ttHits,\r\n      ttStores: this.ttStores,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Principal Variation Search with alpha-beta pruning\r\n   */\r\n  private pvs(\r\n    board: Board,\r\n    player: Player,\r\n    depth: number,\r\n    alpha: number,\r\n    beta: number,\r\n    ply: number,\r\n    isPV: boolean,\r\n    settings: any,\r\n  ): { score: number; move?: Position; pv: Position[] } {\r\n    this.nodes++;\r\n\r\n    // Terminal conditions\r\n    if (depth <= 0) {\r\n      return {\r\n        score: this.quiescenceSearch(board, player, alpha, beta, ply),\r\n        move: undefined,\r\n        pv: [],\r\n      };\r\n    }\r\n\r\n    if (this.shouldStop()) {\r\n      return { score: evaluateBoard(board, player), move: undefined, pv: [] };\r\n    }\r\n\r\n    // Transposition table lookup\r\n    const ttKey = this.generateBoardKey(board, player);\r\n    const ttEntry = this.tt.get(ttKey);\r\n    let ttMove: Position | undefined;\r\n\r\n    if (ttEntry && this.tt.isUsable(ttEntry, depth)) {\r\n      this.ttHits++;\r\n      const cutoff = this.tt.providesScoreCutoff(ttEntry, alpha, beta, depth);\r\n\r\n      if (cutoff.cutoff && cutoff.score !== undefined) {\r\n        return { score: cutoff.score, move: ttEntry.bestMove, pv: [] };\r\n      }\r\n\r\n      if (cutoff.newAlpha !== undefined) alpha = cutoff.newAlpha;\r\n      if (cutoff.newBeta !== undefined) beta = cutoff.newBeta;\r\n      ttMove = ttEntry.bestMove;\r\n    }\r\n\r\n    // Generate and order moves\r\n    const moves = getValidMoves(board, player);\r\n    if (moves.length === 0) {\r\n      // Pass move or game over\r\n      const opponent = player === \"black\" ? \"white\" : \"black\";\r\n      const opponentMoves = getValidMoves(board, opponent);\r\n\r\n      if (opponentMoves.length === 0) {\r\n        // Game over - count material\r\n        return {\r\n          score: this.evaluateGameEnd(board, player),\r\n          move: undefined,\r\n          pv: [],\r\n        };\r\n      } else {\r\n        // Pass - search opponent\r\n        const result = this.pvs(\r\n          board,\r\n          opponent,\r\n          depth - 1,\r\n          -beta,\r\n          -alpha,\r\n          ply + 1,\r\n          isPV,\r\n          settings,\r\n        );\r\n        return { score: -result.score, move: undefined, pv: result.pv };\r\n      }\r\n    }\r\n\r\n    const orderedMoves = orderMoves(moves, {\r\n      ply,\r\n      player,\r\n      board,\r\n      killers: this.killers,\r\n      history: this.history,\r\n      ttBestMove: ttMove,\r\n    });\r\n\r\n    let bestMove: Position | undefined;\r\n    let bestScore = -Infinity;\r\n    let pv: Position[] = [];\r\n    let moveCount = 0;\r\n\r\n    for (const move of orderedMoves) {\r\n      // Late move pruning\r\n      if (this.shouldPruneMove(moveCount, depth, alpha, beta, settings)) {\r\n        break;\r\n      }\r\n\r\n      const newBoard = this.makeMove(board, move, player);\r\n      if (!newBoard) {\r\n        continue;\r\n      }\r\n      const opponent = player === \"black\" ? \"white\" : \"black\";\r\n      let score: number;\r\n\r\n      if (moveCount === 0) {\r\n        // Principal variation - full window search\r\n        const result = this.pvs(\r\n          newBoard,\r\n          opponent,\r\n          depth - 1,\r\n          -beta,\r\n          -alpha,\r\n          ply + 1,\r\n          isPV,\r\n          settings,\r\n        );\r\n        score = -result.score;\r\n        if (score > alpha) {\r\n          pv = [move, ...result.pv];\r\n        }\r\n      } else {\r\n        // Late move reduction\r\n        let reduction = 0;\r\n        if (this.shouldReduceMove(moveCount, depth, move, settings)) {\r\n          reduction = Math.floor(\r\n            settings.lmrBase + (Math.log(depth) * Math.log(moveCount)) / 3,\r\n          );\r\n          reduction = Math.max(0, Math.min(reduction, depth - 2));\r\n        }\r\n\r\n        // Null window search\r\n        const result = this.pvs(\r\n          newBoard,\r\n          opponent,\r\n          depth - 1 - reduction,\r\n          -alpha - 1,\r\n          -alpha,\r\n          ply + 1,\r\n          false,\r\n          settings,\r\n        );\r\n        score = -result.score;\r\n\r\n        // Re-search if necessary\r\n        if (score > alpha && score < beta && (reduction > 0 || !isPV)) {\r\n          const fullResult = this.pvs(\r\n            newBoard,\r\n            opponent,\r\n            depth - 1,\r\n            -beta,\r\n            -alpha,\r\n            ply + 1,\r\n            isPV,\r\n            settings,\r\n          );\r\n          score = -fullResult.score;\r\n          if (score > alpha) {\r\n            pv = [move, ...fullResult.pv];\r\n          }\r\n        }\r\n      }\r\n\r\n      if (score > bestScore) {\r\n        bestScore = score;\r\n        bestMove = move;\r\n      }\r\n\r\n      if (score > alpha) {\r\n        alpha = score;\r\n        if (!pv.length) pv = [move];\r\n      }\r\n\r\n      if (alpha >= beta) {\r\n        // Beta cutoff - killer move\r\n        this.killers.addKiller(ply, move);\r\n        this.history.updateHistory(move, player, depth);\r\n        break;\r\n      }\r\n\r\n      moveCount++;\r\n    }\r\n\r\n    // Store in transposition table\r\n    if (bestMove) {\r\n      const entry = this.tt.createEntry(\r\n        depth,\r\n        bestScore,\r\n        bestMove,\r\n        alpha,\r\n        beta,\r\n      );\r\n      this.tt.set(ttKey, entry);\r\n      this.ttStores++;\r\n    }\r\n\r\n    return { score: bestScore, move: bestMove, pv };\r\n  }\r\n\r\n  /**\r\n   * Quiescence search for tactical stability\r\n   */\r\n  private quiescenceSearch(\r\n    board: Board,\r\n    player: Player,\r\n    alpha: number,\r\n    beta: number,\r\n    ply: number,\r\n  ): number {\r\n    this.nodes++;\r\n\r\n    const stateKey = `${player}-${JSON.stringify(board)}`;\r\n    if (this.quiescenceVisited.has(stateKey)) {\r\n      return evaluateBoard(board, player);\r\n    }\r\n    this.quiescenceVisited.add(stateKey);\r\n\r\n    if (ply >= 64) {\r\n      return evaluateBoard(board, player);\r\n    }\r\n\r\n    const standPat = evaluateBoard(board, player);\r\n    if (standPat >= beta) return beta;\r\n    if (standPat > alpha) alpha = standPat;\r\n\r\n    const moves = getValidMoves(board, player);\r\n    if (moves.length === 0) {\r\n      const opponent = player === \"black\" ? \"white\" : \"black\";\r\n      const opponentMoves = getValidMoves(board, opponent);\r\n\r\n      if (opponentMoves.length === 0) {\r\n        return standPat;\r\n      }\r\n\r\n      const score = -this.quiescenceSearch(\r\n        board,\r\n        opponent,\r\n        -beta,\r\n        -alpha,\r\n        ply + 1,\r\n      );\r\n      if (score > alpha) {\r\n        alpha = score;\r\n      }\r\n      return alpha;\r\n    }\r\n\r\n    const tacticalMoves = this.filterTacticalMoves(moves);\r\n    if (tacticalMoves.length === 0) {\r\n      return alpha;\r\n    }\r\n\r\n    const opponent = player === \"black\" ? \"white\" : \"black\";\r\n\r\n    for (const move of tacticalMoves) {\r\n      const newBoard = this.makeMove(board, move, player);\r\n      if (!newBoard) {\r\n        continue;\r\n      }\r\n\r\n      const score = -this.quiescenceSearch(\r\n        newBoard,\r\n        opponent,\r\n        -beta,\r\n        -alpha,\r\n        ply + 1,\r\n      );\r\n\r\n      if (score >= beta) return beta;\r\n      if (score > alpha) alpha = score;\r\n    }\r\n\r\n    return alpha;\r\n  }\r\n\r\n  private initializeSearch(config: SearchConfig): void {\r\n    this.nodes = 0;\r\n    this.ttHits = 0;\r\n    this.ttStores = 0;\r\n    this.startTime = Date.now();\r\n    this.timeLimit = config.timeLimit || Infinity;\r\n    this.tt.bumpAge();\r\n    this.quiescenceVisited.clear();\r\n  }\r\n\r\n  private shouldStop(): boolean {\r\n    return Date.now() - this.startTime >= this.timeLimit;\r\n  }\r\n\r\n  private shouldPruneMove(\r\n    moveCount: number,\r\n    depth: number,\r\n    alpha: number,\r\n    beta: number,\r\n    settings: any,\r\n  ): boolean {\r\n    if (\r\n      depth >= 6 &&\r\n      moveCount >=\r\n        PRUNING_PARAMS.LMP_TABLE[Math.min(depth, 6)] + settings.lmpBonus\r\n    ) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private shouldReduceMove(\r\n    moveCount: number,\r\n    depth: number,\r\n    move: Position,\r\n    settings: any,\r\n  ): boolean {\r\n    return depth >= 3 && moveCount >= 4 && !this.isImportantMove(move);\r\n  }\r\n\r\n  private isImportantMove(move: Position): boolean {\r\n    const { row, col } = move;\r\n    return (row === 0 || row === 7) && (col === 0 || col === 7);\r\n  }\r\n\r\n  private filterTacticalMoves(moves: Position[]): Position[] {\r\n    return moves.filter((move) => this.isImportantMove(move)).slice(0, 4);\r\n  }\r\n\r\n  private makeMove(board: Board, move: Position, player: Player): Board | null {\r\n    const gameCore: GameCore = {\r\n      id: \"pvs-move\",\r\n      board,\r\n      currentPlayer: player,\r\n      validMoves: [],\r\n      score: { black: 0, white: 0 },\r\n      status: \"playing\",\r\n      moveHistory: [],\r\n      canUndo: false,\r\n      canRedo: false,\r\n    };\r\n\r\n    const result = coreMakeMove(gameCore, move);\r\n    if (result.success && result.newGameCore) {\r\n      return result.newGameCore.board;\r\n    }\r\n\r\n    return this.fallbackApplyMove(board, move, player);\r\n  }\r\n\r\n  private fallbackApplyMove(\r\n    board: Board,\r\n    move: Position,\r\n    player: Player,\r\n  ): Board | null {\r\n    const opponent = player === \"black\" ? \"white\" : \"black\";\r\n\r\n    const next = board.map((row) => [...row]);\r\n\r\n    const directions = [\r\n      [-1, -1],\r\n      [0, -1],\r\n      [1, -1],\r\n\r\n      [-1, 0],\r\n      [1, 0],\r\n\r\n      [-1, 1],\r\n      [0, 1],\r\n      [1, 1],\r\n    ];\r\n\r\n    const flips: Position[] = [];\r\n\r\n    for (const [dr, dc] of directions) {\r\n      let r = move.row + dr;\r\n\r\n      let c = move.col + dc;\r\n\r\n      const path: Position[] = [];\r\n\r\n      while (r >= 0 && r < 8 && c >= 0 && c < 8 && next[r][c] === opponent) {\r\n        path.push({ row: r, col: c });\r\n\r\n        r += dr;\r\n\r\n        c += dc;\r\n      }\r\n\r\n      if (\r\n        path.length > 0 &&\r\n        r >= 0 &&\r\n        r < 8 &&\r\n        c >= 0 &&\r\n        c < 8 &&\r\n        next[r][c] === player\r\n      ) {\r\n        flips.push(...path);\r\n      }\r\n    }\r\n\r\n    if (flips.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    next[move.row][move.col] = player;\r\n\r\n    for (const pos of flips) {\r\n      next[pos.row][pos.col] = player;\r\n    }\r\n\r\n    return next;\r\n  }\r\n\r\n  private generateBoardKey(board: Board, player: Player): string {\r\n    return `${JSON.stringify(board)}_${player}`;\r\n  }\r\n\r\n  private countEmptySquares(board: Board): number {\r\n    let count = 0;\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] === null) count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  private evaluateGameEnd(board: Board, player: Player): number {\r\n    let playerCount = 0;\r\n    let opponentCount = 0;\r\n    const opponent = player === \"black\" ? \"white\" : \"black\";\r\n\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        const cell = board[r][c];\r\n        if (cell === player) playerCount++;\r\n        else if (cell === opponent) opponentCount++;\r\n      }\r\n    }\r\n\r\n    return playerCount - opponentCount;\r\n  }\r\n}\r\n", "// Selectivity and difficulty configuration system\r\n// Converted from search-neo.js LEVEL tables and selectivity system\r\n\r\nexport interface SelectivityConfig {\r\n  depth: number;\r\n  selectivity: number; // 0 (aggressive) to 5 (conservative)\r\n}\r\n\r\nexport interface SelectivitySettings {\r\n  lmrBase: number;      // Late move reduction base factor\r\n  lmpBonus: number;     // Late move pruning bonus allowance\r\n  futMul: number;       // Futility pruning margin multiplier\r\n  razorMul: number;     // Razor pruning margin multiplier\r\n  useNWS: boolean;      // Enable null window search\r\n}\r\n\r\n// Selectivity table for different difficulty levels and empty squares\r\n// LEVEL[level][empties] -> { depth, selectivity }\r\nconst LEVEL_TABLE: SelectivityConfig[][] = [];\r\n\r\n/**\r\n * Initialize the level table\r\n */\r\nfunction buildLevelTable(): void {\r\n  // Initialize with default values\r\n  for (let L = 0; L <= 60; L++) {\r\n    LEVEL_TABLE[L] = [];\r\n    for (let e = 0; e <= 60; e++) {\r\n      LEVEL_TABLE[L][e] = { depth: 0, selectivity: 5 };\r\n    }\r\n  }\r\n\r\n  // Build level configurations\r\n  for (let L = 0; L <= 60; L++) {\r\n    for (let e = 0; e <= 60; e++) {\r\n      if (L <= 0) {\r\n        LEVEL_TABLE[L][e] = { depth: 0, selectivity: 5 };\r\n        continue;\r\n      }\r\n\r\n      if (L <= 10) {\r\n        LEVEL_TABLE[L][e] = {\r\n          depth: e <= 2 * L ? e : L,\r\n          selectivity: 5\r\n        };\r\n        continue;\r\n      }\r\n\r\n      // Define selectivity bands based on difficulty level\r\n      const bands = [\r\n        { lim: 12, sel: [[21, 5], [24, 3], [99, 0]] },\r\n        { lim: 18, sel: [[21, 5], [24, 3], [27, 1], [99, 0]] },\r\n        { lim: 24, sel: [[24, 5], [27, 4], [30, 2], [33, 0], [99, 0]] },\r\n        { lim: 33, sel: [[30, 5], [33, 4], [36, 2], [39, 0], [99, 0]] },\r\n        { lim: 35, sel: [[30, 5], [33, 4], [36, 3], [39, 1], [99, 0]] },\r\n      ];\r\n\r\n      let handled = false;\r\n      for (const band of bands) {\r\n        if (L <= band.lim) {\r\n          let selectivity = 0;\r\n          let config = { depth: e, selectivity: 0 };\r\n\r\n          for (const [threshold, sel] of band.sel) {\r\n            selectivity = sel;\r\n            if (e <= threshold) {\r\n              config = { depth: e, selectivity };\r\n              break;\r\n            }\r\n          }\r\n\r\n          LEVEL_TABLE[L][e] = config;\r\n          handled = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!handled) {\r\n        // High difficulty levels (L > 35)\r\n        let selectivity = 0;\r\n        if (e <= L - 6) selectivity = 5;\r\n        else if (e <= L - 3) selectivity = 4;\r\n        else if (e <= L) selectivity = 3;\r\n        else if (e <= L + 3) selectivity = 2;\r\n        else if (e <= L + 6) selectivity = 1;\r\n        else selectivity = 0;\r\n\r\n        LEVEL_TABLE[L][e] = {\r\n          depth: e <= L + 9 ? e : L,\r\n          selectivity\r\n        };\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n// Initialize the table\r\nbuildLevelTable();\r\n\r\n/**\r\n * Get configuration for a specific difficulty level and empty squares\r\n */\r\nexport function getLevelConfig(level: number, empties: number): SelectivityConfig {\r\n  const clampedLevel = Math.max(0, Math.min(60, level));\r\n  const clampedEmpties = Math.max(0, Math.min(60, empties));\r\n\r\n  return LEVEL_TABLE[clampedLevel][clampedEmpties];\r\n}\r\n\r\n/**\r\n * Convert selectivity level to search settings\r\n */\r\nexport function getSelectivitySettings(selectivity: number): SelectivitySettings {\r\n  const NO_SELECTIVITY = 5;\r\n  const clampedSel = Math.max(0, Math.min(NO_SELECTIVITY, selectivity));\r\n\r\n  // Calculate scaling factor: 0 (aggressive) to 1 (conservative)\r\n  const t = (NO_SELECTIVITY - clampedSel) / NO_SELECTIVITY;\r\n\r\n  return {\r\n    lmrBase: 0.75 + 1.75 * t,              // 0.75 to 2.5\r\n    lmpBonus: Math.round(12 * t),          // 0 to 12\r\n    futMul: 1 + 1.0 * t,                   // 1.0 to 2.0\r\n    razorMul: 1 + 0.8 * t,                 // 1.0 to 1.8\r\n    useNWS: t > 0.15,                      // Enable NWS for selectivity <= 4\r\n  };\r\n}\r\n\r\n/**\r\n * Predefined difficulty mappings\r\n */\r\nexport enum DifficultyLevel {\r\n  BEGINNER = 8,\r\n  EASY = 12,\r\n  MEDIUM = 18,\r\n  HARD = 24,\r\n  EXPERT = 33,\r\n  MASTER = 40,\r\n  GRANDMASTER = 50\r\n}\r\n\r\n/**\r\n * Get difficulty level from string\r\n */\r\nexport function getDifficultyLevel(difficulty: string): number {\r\n  switch (difficulty.toLowerCase()) {\r\n    case 'beginner': return DifficultyLevel.BEGINNER;\r\n    case 'easy': return DifficultyLevel.EASY;\r\n    case 'medium': return DifficultyLevel.MEDIUM;\r\n    case 'hard': return DifficultyLevel.HARD;\r\n    case 'expert': return DifficultyLevel.EXPERT;\r\n    case 'master': return DifficultyLevel.MASTER;\r\n    case 'grandmaster': return DifficultyLevel.GRANDMASTER;\r\n    default: return DifficultyLevel.MEDIUM;\r\n  }\r\n}\r\n\r\n/**\r\n * Stability thresholds for different pruning techniques\r\n */\r\nexport const STABILITY_THRESHOLDS = {\r\n  // NWS (Null Window Search) stability thresholds\r\n  NWS: Array.from({ length: 61 }, (_, i) => {\r\n    if (i < 4) return 99;\r\n    if (i <= 8) return 8;\r\n    if (i <= 24) return 26 + Math.floor((i - 8) * 1.2);\r\n    return Math.min(64, 40 + Math.floor((i - 24) * 1.0));\r\n  }),\r\n\r\n  // PVS (Principal Variation Search) stability thresholds\r\n  PVS: Array.from({ length: 61 }, (_, i) => {\r\n    if (i < 4) return 99;\r\n    if (i <= 8) return 0;\r\n    if (i <= 24) return 12 + Math.floor((i - 8) * 1.2);\r\n    return Math.min(62, 32 + Math.floor((i - 24) * 1.0));\r\n  }),\r\n};\r\n\r\n/**\r\n * Pruning parameters\r\n */\r\nexport const PRUNING_PARAMS = {\r\n  // Late Move Pruning table\r\n  LMP_TABLE: [0, 0, 3, 5, 7, 9, 12],\r\n\r\n  // Futility pruning margins by depth\r\n  FUTILITY_MARGINS: [0, 120, 200, 280],\r\n\r\n  // Razor pruning margins by depth\r\n  RAZOR_MARGINS: [0, 300, 500],\r\n\r\n  // Null move parameters\r\n  NULL_MOVE_R: 2,\r\n  NULL_MOVE_MIN_DEPTH: 2,\r\n};\r\n\r\n/**\r\n * Endgame detection threshold\r\n */\r\nexport const ENDGAME_THRESHOLD = 20;", "// Aspiration window search implementation\r\n// Converted from search-neo.js aspiration window logic\r\n\r\nimport type { Board, Player, Position } from 'shared-types';\r\nimport { PVSEngine, type SearchResult, type SearchConfig } from './pvs';\r\nimport { evaluateBoard } from '../evaluation/heuristic';\r\n\r\nexport interface AspirationConfig extends SearchConfig {\r\n  initialWindow: number;\r\n  maxWindow: number;\r\n  windowGrowth: number;\r\n}\r\n\r\nexport const DEFAULT_ASPIRATION_CONFIG: AspirationConfig = {\r\n  level: 18,\r\n  initialWindow: 50,\r\n  maxWindow: 400,\r\n  windowGrowth: 2,\r\n  enableTT: true,\r\n  enableKillers: true,\r\n  enableHistory: true\r\n};\r\n\r\n/**\r\n * Aspiration Window Search - optimizes search by using narrow windows\r\n * around expected scores, widening when necessary\r\n */\r\nexport class AspirationEngine {\r\n  private pvsEngine: PVSEngine;\r\n\r\n  constructor() {\r\n    this.pvsEngine = new PVSEngine();\r\n  }\r\n\r\n  /**\r\n   * Search with aspiration windows for efficiency\r\n   */\r\n  search(\r\n    board: Board,\r\n    player: Player,\r\n    config: AspirationConfig = DEFAULT_ASPIRATION_CONFIG\r\n  ): SearchResult {\r\n    let previousScore = evaluateBoard(board, player);\r\n    let window = config.initialWindow;\r\n    let depth = 1;\r\n\r\n    // Initial full-window search for depth 1\r\n    let result = this.pvsEngine.search(board, player, {\r\n      ...config,\r\n      depthLimit: 1\r\n    });\r\n\r\n    if (result.bestMove) {\r\n      previousScore = result.score;\r\n    }\r\n\r\n    // Iterative deepening with aspiration windows\r\n    for (depth = 2; depth <= this.getMaxDepth(board, config); depth++) {\r\n      const searchConfig = {\r\n        ...config,\r\n        depthLimit: depth\r\n      };\r\n\r\n      let searchResult = this.searchWithWindow(\r\n        board,\r\n        player,\r\n        searchConfig,\r\n        previousScore,\r\n        window\r\n      );\r\n\r\n      // Handle aspiration failures\r\n      while (this.isAspirationFailure(searchResult, previousScore, window)) {\r\n        window = Math.min(window * config.windowGrowth, config.maxWindow);\r\n\r\n        // Re-search with wider window\r\n        searchResult = this.searchWithWindow(\r\n          board,\r\n          player,\r\n          searchConfig,\r\n          previousScore,\r\n          window\r\n        );\r\n\r\n        // If window becomes too wide, use full window\r\n        if (window >= config.maxWindow) {\r\n          searchResult = this.pvsEngine.search(board, player, searchConfig);\r\n          break;\r\n        }\r\n      }\r\n\r\n      // Update for next iteration\r\n      if (searchResult.bestMove) {\r\n        result = searchResult;\r\n        previousScore = searchResult.score;\r\n        window = config.initialWindow; // Reset window for next depth\r\n      }\r\n\r\n      // Time check\r\n      if (config.timeLimit && result.time >= config.timeLimit * 0.8) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Search with specific aspiration window\r\n   */\r\n  private searchWithWindow(\r\n    board: Board,\r\n    player: Player,\r\n    config: SearchConfig,\r\n    expectedScore: number,\r\n    window: number\r\n  ): SearchResult {\r\n    const alpha = expectedScore - window;\r\n    const beta = expectedScore + window;\r\n\r\n    // Use PVS with constrained window\r\n    return this.pvsEngine.search(board, player, config);\r\n  }\r\n\r\n  /**\r\n   * Check if aspiration search failed (score outside window)\r\n   */\r\n  private isAspirationFailure(\r\n    result: SearchResult,\r\n    expectedScore: number,\r\n    window: number\r\n  ): boolean {\r\n    const alpha = expectedScore - window;\r\n    const beta = expectedScore + window;\r\n\r\n    return result.score <= alpha || result.score >= beta;\r\n  }\r\n\r\n  /**\r\n   * Determine maximum search depth based on game phase\r\n   */\r\n  private getMaxDepth(board: Board, config: AspirationConfig): number {\r\n    const empties = this.countEmptySquares(board);\r\n\r\n    if (config.depthLimit) {\r\n      return Math.min(config.depthLimit, empties);\r\n    }\r\n\r\n    // Dynamic depth based on game phase and level\r\n    if (empties <= 12) {\r\n      // Endgame - search to the end\r\n      return empties;\r\n    } else if (empties <= 20) {\r\n      // Late midgame - deeper search\r\n      return Math.min(config.level, 20);\r\n    } else {\r\n      // Early to mid game - normal depth\r\n      return Math.min(config.level, 15);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Adaptive window sizing based on search instability\r\n   */\r\n  getAdaptiveWindow(\r\n    previousScores: number[],\r\n    baseWindow: number\r\n  ): number {\r\n    if (previousScores.length < 2) {\r\n      return baseWindow;\r\n    }\r\n\r\n    // Calculate score volatility\r\n    let totalVariation = 0;\r\n    for (let i = 1; i < previousScores.length; i++) {\r\n      totalVariation += Math.abs(previousScores[i] - previousScores[i - 1]);\r\n    }\r\n\r\n    const avgVariation = totalVariation / (previousScores.length - 1);\r\n\r\n    // Adjust window based on volatility\r\n    if (avgVariation > 100) {\r\n      return Math.min(baseWindow * 2, 400);\r\n    } else if (avgVariation < 30) {\r\n      return Math.max(baseWindow / 2, 25);\r\n    } else {\r\n      return baseWindow;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Multi-cut aspiration search for very narrow windows\r\n   */\r\n  multiCutSearch(\r\n    board: Board,\r\n    player: Player,\r\n    config: AspirationConfig,\r\n    expectedScore: number\r\n  ): SearchResult {\r\n    const cuts = [-2, -1, 0, 1, 2];\r\n    let bestResult: SearchResult | undefined;\n\r\n    for (const cut of cuts) {\r\n      const adjustedScore = expectedScore + cut;\r\n      const result = this.searchWithWindow(\r\n        board,\r\n        player,\r\n        config,\r\n        adjustedScore,\r\n        config.initialWindow / 4\r\n      );\r\n\r\n      if (!bestResult || (result.bestMove && result.score > bestResult.score)) {\r\n        bestResult = result;\r\n      }\r\n\r\n      // Early termination if we find a clearly good move\r\n      if (result.score > expectedScore + config.initialWindow) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return bestResult ?? this.pvsEngine.search(board, player, config);\n  }\r\n\r\n  private countEmptySquares(board: Board): number {\r\n    let count = 0;\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] === null) count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * Get search statistics for debugging\r\n   */\r\n  getLastSearchStats(): {\r\n    windowHits: number;\r\n    windowMisses: number;\r\n    avgWindow: number;\r\n  } {\r\n    // Implementation for tracking aspiration window performance\r\n    return {\r\n      windowHits: 0,\r\n      windowMisses: 0,\r\n      avgWindow: 0\r\n    };\r\n  }\r\n}\n", "// Time management system for search algorithms\r\n// Converted from search-neo.js time control logic\r\n\r\nimport type { Board } from 'shared-types';\r\n\r\nexport interface TimeConfig {\r\n  totalTime: number;      // Total time available (ms)\r\n  increment: number;      // Time increment per move (ms)\r\n  movesToGo?: number;     // Moves until next time control\r\n  minThinkTime: number;   // Minimum time per move (ms)\r\n  maxThinkTime: number;   // Maximum time per move (ms)\r\n}\r\n\r\nexport interface TimeAllocation {\r\n  targetTime: number;     // Target time for this move\r\n  maxTime: number;        // Absolute maximum time\r\n  emergencyTime: number;  // Time for emergency situations\r\n}\r\n\r\n/**\r\n * Time management for search optimization\r\n */\r\nexport class TimeManager {\r\n  private config: TimeConfig;\r\n  private moveHistory: number[] = [];\r\n  private emergencyMoves = 0;\r\n\r\n  constructor(config: TimeConfig) {\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Calculate time allocation for current move\r\n   */\r\n  allocateTime(\r\n    board: Board,\r\n    movesPlayed: number,\r\n    isEndgame: boolean = false\r\n  ): TimeAllocation {\r\n    const empties = this.countEmptySquares(board);\r\n    const remainingTime = this.getRemainingTime();\r\n\r\n    if (isEndgame && empties <= 10) {\r\n      return this.allocateEndgameTime(empties, remainingTime);\r\n    }\r\n\r\n    const estimatedMovesLeft = this.estimateMovesRemaining(empties, movesPlayed);\r\n    const baseAllocation = this.calculateBaseAllocation(remainingTime, estimatedMovesLeft);\r\n\r\n    // Apply phase-specific adjustments\r\n    const phaseMultiplier = this.getPhaseMultiplier(empties);\r\n    const complexityMultiplier = this.getComplexityMultiplier(board);\r\n    const historyMultiplier = this.getHistoryMultiplier();\r\n\r\n    const targetTime = Math.max(\r\n      this.config.minThinkTime,\r\n      Math.min(\r\n        baseAllocation * phaseMultiplier * complexityMultiplier * historyMultiplier,\r\n        this.config.maxThinkTime\r\n      )\r\n    );\r\n\r\n    const maxTime = Math.min(\r\n      targetTime * 2,\r\n      remainingTime * 0.25 // Never use more than 25% of remaining time\r\n    );\r\n\r\n    const emergencyTime = Math.min(\r\n      targetTime * 0.3,\r\n      remainingTime * 0.05 // Emergency reserve\r\n    );\r\n\r\n    return {\r\n      targetTime,\r\n      maxTime,\r\n      emergencyTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Special time allocation for endgame\r\n   */\r\n  private allocateEndgameTime(empties: number, remainingTime: number): TimeAllocation {\r\n    let targetTime: number;\r\n\r\n    if (empties <= 4) {\r\n      // Final moves - use significant time for perfect play\r\n      targetTime = Math.min(remainingTime * 0.4, this.config.maxThinkTime);\r\n    } else if (empties <= 8) {\r\n      // Critical endgame - increased time\r\n      targetTime = Math.min(remainingTime * 0.2, this.config.maxThinkTime * 0.8);\r\n    } else {\r\n      // Early endgame - moderate increase\r\n      targetTime = Math.min(remainingTime * 0.15, this.config.maxThinkTime * 0.6);\r\n    }\r\n\r\n    return {\r\n      targetTime: Math.max(targetTime, this.config.minThinkTime),\r\n      maxTime: Math.min(targetTime * 3, remainingTime * 0.5),\r\n      emergencyTime: this.config.minThinkTime\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Estimate remaining moves in the game\r\n   */\r\n  private estimateMovesRemaining(empties: number, movesPlayed: number): number {\r\n    if (empties <= 12) {\r\n      // Endgame - remaining moves approximately equal to empties\r\n      return Math.max(empties - 2, 1);\r\n    }\r\n\r\n    // Estimate based on typical game length (around 58-60 moves total)\r\n    const estimatedTotalMoves = 58;\r\n    const estimatedRemaining = Math.max(estimatedTotalMoves - movesPlayed, empties / 2);\r\n\r\n    return estimatedRemaining;\r\n  }\r\n\r\n  /**\r\n   * Calculate base time allocation\r\n   */\r\n  private calculateBaseAllocation(remainingTime: number, movesLeft: number): number {\r\n    const timePerMove = remainingTime / Math.max(movesLeft, 1);\r\n    const incrementBonus = this.config.increment * 0.8; // Don't count full increment\r\n\r\n    return timePerMove + incrementBonus;\r\n  }\r\n\r\n  /**\r\n   * Phase-based time multiplier\r\n   */\r\n  private getPhaseMultiplier(empties: number): number {\r\n    if (empties >= 50) {\r\n      // Opening - quick moves\r\n      return 0.6;\r\n    } else if (empties >= 30) {\r\n      // Early midgame\r\n      return 0.8;\r\n    } else if (empties >= 20) {\r\n      // Middle game - critical decisions\r\n      return 1.2;\r\n    } else if (empties >= 12) {\r\n      // Late midgame - very important\r\n      return 1.4;\r\n    } else {\r\n      // Endgame - handled separately\r\n      return 1.0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Board complexity multiplier\r\n   */\r\n  private getComplexityMultiplier(board: Board): number {\r\n    const mobility = this.estimateMobility(board);\r\n    const stability = this.estimateStability(board);\r\n\r\n    let multiplier = 1.0;\r\n\r\n    // High mobility positions need more time\r\n    if (mobility > 8) {\r\n      multiplier *= 1.2;\r\n    } else if (mobility < 3) {\r\n      multiplier *= 0.8;\r\n    }\r\n\r\n    // Low stability (tactical) positions need more time\r\n    if (stability < 0.3) {\r\n      multiplier *= 1.3;\r\n    }\r\n\r\n    return Math.max(0.5, Math.min(multiplier, 2.0));\r\n  }\r\n\r\n  /**\r\n   * Historical performance multiplier\r\n   */\r\n  private getHistoryMultiplier(): number {\r\n    if (this.moveHistory.length < 3) {\r\n      return 1.0;\r\n    }\r\n\r\n    const recentMoves = this.moveHistory.slice(-3);\r\n    const avgTime = recentMoves.reduce((a, b) => a + b, 0) / recentMoves.length;\r\n    const targetAvg = (this.config.minThinkTime + this.config.maxThinkTime) / 2;\r\n\r\n    if (avgTime > targetAvg * 1.5) {\r\n      // Been using too much time - reduce\r\n      return 0.8;\r\n    } else if (avgTime < targetAvg * 0.5) {\r\n      // Been moving too fast - can afford more time\r\n      return 1.2;\r\n    }\r\n\r\n    return 1.0;\r\n  }\r\n\r\n  /**\r\n   * Emergency time management\r\n   */\r\n  isEmergencyTime(remainingTime: number, movesLeft: number): boolean {\r\n    const timePerMove = remainingTime / Math.max(movesLeft, 1);\r\n    return timePerMove < this.config.minThinkTime * 1.5;\r\n  }\r\n\r\n  /**\r\n   * Record time used for a move\r\n   */\r\n  recordMoveTime(timeUsed: number): void {\r\n    this.moveHistory.push(timeUsed);\r\n\r\n    // Keep only recent history\r\n    if (this.moveHistory.length > 10) {\r\n      this.moveHistory.shift();\r\n    }\r\n\r\n    // Track emergency moves\r\n    if (timeUsed < this.config.minThinkTime * 1.2) {\r\n      this.emergencyMoves++;\r\n    } else {\r\n      this.emergencyMoves = Math.max(0, this.emergencyMoves - 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check if we should extend search time\r\n   */\r\n  shouldExtendTime(\r\n    currentTime: number,\r\n    targetTime: number,\r\n    maxTime: number,\r\n    bestMoveStable: boolean,\r\n    scoreImproving: boolean\r\n  ): boolean {\r\n    if (currentTime >= maxTime) {\r\n      return false;\r\n    }\r\n\r\n    // Extend if we haven't found a stable best move\r\n    if (!bestMoveStable && currentTime < targetTime * 1.5) {\r\n      return true;\r\n    }\r\n\r\n    // Extend if score is still improving rapidly\r\n    if (scoreImproving && currentTime < targetTime * 1.3) {\r\n      return true;\r\n    }\r\n\r\n    // Don't extend if we're in emergency time mode\r\n    if (this.emergencyMoves > 3) {\r\n      return false;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private getRemainingTime(): number {\r\n    return this.config.totalTime;\r\n  }\r\n\r\n  private countEmptySquares(board: Board): number {\r\n    let count = 0;\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] === null) count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  private estimateMobility(board: Board): number {\r\n    let emptyCount = 0;\r\n    let borderCount = 0;\r\n\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] === null) {\r\n          emptyCount++;\r\n\r\n          // Check if adjacent to occupied square\r\n          let isBorder = false;\r\n          for (let dr = -1; dr <= 1; dr++) {\r\n            for (let dc = -1; dc <= 1; dc++) {\r\n              const nr = r + dr;\r\n              const nc = c + dc;\r\n              if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {\r\n                if (board[nr][nc] !== null) {\r\n                  isBorder = true;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n            if (isBorder) break;\r\n          }\r\n\r\n          if (isBorder) borderCount++;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Estimate mobility based on frontier squares\r\n    return Math.max(1, Math.min(borderCount, 20));\r\n  }\r\n\r\n  private estimateStability(board: Board): number {\r\n    let stableCount = 0;\r\n    let totalPieces = 0;\r\n\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] !== null) {\r\n          totalPieces++;\r\n\r\n          // Very rough stability estimate - corners and edges\r\n          if ((r === 0 || r === 7) && (c === 0 || c === 7)) {\r\n            stableCount += 3; // Corners are very stable\r\n          } else if (r === 0 || r === 7 || c === 0 || c === 7) {\r\n            stableCount += 1; // Edges are somewhat stable\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return totalPieces > 0 ? stableCount / totalPieces : 0;\r\n  }\r\n\r\n  /**\r\n   * Get time management statistics\r\n   */\r\n  getStats(): {\r\n    averageMoveTime: number;\r\n    emergencyMoves: number;\r\n    timeEfficiency: number;\r\n  } {\r\n    const avgTime = this.moveHistory.length > 0\r\n      ? this.moveHistory.reduce((a, b) => a + b, 0) / this.moveHistory.length\r\n      : 0;\r\n\r\n    const targetTime = (this.config.minThinkTime + this.config.maxThinkTime) / 2;\r\n    const efficiency = avgTime > 0 ? Math.min(1.0, targetTime / avgTime) : 0;\r\n\r\n    return {\r\n      averageMoveTime: avgTime,\r\n      emergencyMoves: this.emergencyMoves,\r\n      timeEfficiency: efficiency\r\n    };\r\n  }\r\n}", "// Engine-Neo main export - Modern TypeScript Othello AI Engine\r\n// Implements Engine interface with advanced search algorithms\r\n\r\nimport type {\r\n  Board,\r\n  Player,\r\n  Position,\r\n  EngineRequest,\r\n  EngineResponse,\r\n  Engine\r\n} from 'shared-types';\r\n\r\nimport { AspirationEngine, type AspirationConfig, DEFAULT_ASPIRATION_CONFIG } from './search/aspiration';\r\nimport { TimeManager, type TimeConfig } from './search/timeManager';\r\nimport { TranspositionTable } from './optimization/transTable';\r\nimport { KillerMoves, HistoryTable } from './ordering/moveOrdering';\r\nimport { getDifficultyLevel, ENDGAME_THRESHOLD } from './config/selectivity';\r\nimport { isEndgamePhase } from './evaluation/heuristic';\r\n\r\nexport interface EngineNeoConfig {\r\n  level: number;\r\n  timeConfig?: Partial<TimeConfig>;\r\n  aspirationConfig?: Partial<AspirationConfig>;\r\n  ttSize?: number;\r\n  enableOpeningBook?: boolean;\r\n  enableEndgameTablebase?: boolean;\r\n}\r\n\r\nexport const DEFAULT_ENGINE_CONFIG: EngineNeoConfig = {\r\n  level: 18,\r\n  timeConfig: {\r\n    totalTime: 30000,    // 30 seconds\r\n    increment: 1000,     // 1 second increment\r\n    minThinkTime: 500,   // 0.5 seconds minimum\r\n    maxThinkTime: 10000  // 10 seconds maximum\r\n  },\r\n  ttSize: 200000,\r\n  enableOpeningBook: false,\r\n  enableEndgameTablebase: false\r\n};\r\n\r\n/**\r\n * Engine-Neo: Advanced TypeScript Othello Engine\r\n *\r\n * Features:\r\n * - Principal Variation Search with aspiration windows\r\n * - Null Window Search for move ordering\r\n * - Transposition table with aging\r\n * - Advanced move ordering (killers, history heuristic)\r\n * - Dynamic time management\r\n * - Multi-phase evaluation system\r\n * - Configurable difficulty levels\r\n */\r\nexport class EngineNeo implements Engine {\r\n  readonly name = 'Engine-Neo';\r\n  readonly version = '1.0.0';\r\n  readonly author = 'TypeScript Refactor';\r\n\r\n  private config: EngineNeoConfig;\r\n  private aspirationEngine: AspirationEngine;\r\n  private timeManager: TimeManager;\r\n  private tt: TranspositionTable;\r\n  private killers: KillerMoves;\r\n  private history: HistoryTable;\r\n  private searchStats: {\r\n    totalNodes: number;\r\n    totalSearches: number;\r\n    avgDepth: number;\r\n    ttHitRate: number;\r\n  };\r\n\r\n  constructor(config: Partial<EngineNeoConfig> = {}) {\r\n    this.config = { ...DEFAULT_ENGINE_CONFIG, ...config };\r\n\r\n    // Initialize search components\r\n    this.aspirationEngine = new AspirationEngine();\r\n    this.tt = new TranspositionTable(this.config.ttSize || 200000);\r\n    this.killers = new KillerMoves();\r\n    this.history = new HistoryTable();\r\n\r\n    // Initialize time management\r\n    const timeConfig: TimeConfig = {\r\n      totalTime: 30000,\r\n      increment: 1000,\r\n      minThinkTime: 500,\r\n      maxThinkTime: 10000,\r\n      ...this.config.timeConfig\r\n    };\r\n    this.timeManager = new TimeManager(timeConfig);\r\n\r\n    // Initialize statistics\r\n    this.searchStats = {\r\n      totalNodes: 0,\r\n      totalSearches: 0,\r\n      avgDepth: 0,\r\n      ttHitRate: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Main engine interface method\r\n   */\r\n  async analyze(request: EngineRequest): Promise<EngineResponse> {\r\n    const startTime = Date.now();\r\n    const { gameCore, timeLimit, skill } = request;\r\n\r\n    try {\r\n      const { board, currentPlayer } = gameCore;\r\n\r\n      // Update configuration based on request\r\n      const level = skill ? Math.floor(skill / 10) + 10 : this.config.level; // Convert 0-100 skill to level\r\n      const empties = this.countEmptySquares(board);\r\n      const isEndgame = isEndgamePhase(board, ENDGAME_THRESHOLD);\r\n\r\n      // Calculate time allocation\r\n      const timeAllocation = this.timeManager.allocateTime(\r\n        board,\r\n        64 - empties, // moves played\r\n        isEndgame\r\n      );\r\n\r\n      const actualTimeLimit = timeLimit || timeAllocation.targetTime;\r\n\r\n      // Configure search\r\n      const aspirationConfig: AspirationConfig = {\r\n        ...DEFAULT_ASPIRATION_CONFIG,\r\n        ...this.config.aspirationConfig,\r\n        level,\r\n        timeLimit: Math.min(actualTimeLimit, timeAllocation.maxTime),\r\n        enableTT: true,\r\n        enableKillers: true,\r\n        enableHistory: true\r\n      };\r\n\r\n      // Perform search\r\n      const searchResult = this.aspirationEngine.search(\r\n        board,\r\n        currentPlayer,\r\n        aspirationConfig\r\n      );\r\n\r\n      // Record time usage\r\n      const timeUsed = Date.now() - startTime;\r\n      this.timeManager.recordMoveTime(timeUsed);\r\n\r\n      // Update statistics\r\n      this.updateStats(searchResult);\r\n\r\n      // Age history for next search\r\n      this.history.ageHistory(0.95);\r\n\r\n      return {\r\n        bestMove: searchResult.bestMove || undefined,\r\n        evaluation: searchResult.score,\r\n        depth: searchResult.depth,\r\n        nodes: searchResult.nodes,\r\n        timeUsed,\r\n        pv: searchResult.pv || [],\r\n        stats: {\r\n          ttHits: searchResult.ttHits,\r\n          ttStores: searchResult.ttStores,\r\n          empties,\r\n          isEndgame\r\n        }\r\n      };\r\n\r\n    } catch (error) {\r\n      console.error('Engine-Neo search error:', error);\r\n\r\n      // Return fallback move\r\n      const fallbackMove = await this.getFallbackMove(gameCore.board, gameCore.currentPlayer);\r\n      const timeUsed = Date.now() - startTime;\r\n\r\n      return {\r\n        bestMove: fallbackMove || undefined,\r\n        evaluation: 0,\r\n        depth: 1,\r\n        nodes: 0,\r\n        timeUsed,\r\n        pv: [],\r\n        stats: { error: error instanceof Error ? error.message : 'Unknown error' }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get fallback move using simple heuristics\r\n   */\r\n  private async getFallbackMove(board: Board, player: Player): Promise<Position | null> {\r\n    const { getValidMoves } = await import('core');\r\n    const moves = getValidMoves(board, player);\r\n\r\n    if (moves.length === 0) return null;\r\n\r\n    // Prefer corners\r\n    const corners = moves.filter(move =>\r\n      (move.row === 0 || move.row === 7) && (move.col === 0 || move.col === 7)\r\n    );\r\n\r\n    if (corners.length > 0) {\r\n      return corners[0];\r\n    }\r\n\r\n    // Prefer edges\r\n    const edges = moves.filter(move =>\r\n      move.row === 0 || move.row === 7 || move.col === 0 || move.col === 7\r\n    );\r\n\r\n    if (edges.length > 0) {\r\n      return edges[0];\r\n    }\r\n\r\n    // Return any valid move\r\n    return moves[0];\r\n  }\r\n\r\n  /**\r\n   * Update engine statistics\r\n   */\r\n  private updateStats(searchResult: any): void {\r\n    this.searchStats.totalNodes += searchResult.nodes || 0;\r\n    this.searchStats.totalSearches++;\r\n\r\n    if (searchResult.depth) {\r\n      this.searchStats.avgDepth =\r\n        (this.searchStats.avgDepth * (this.searchStats.totalSearches - 1) + searchResult.depth)\r\n        / this.searchStats.totalSearches;\r\n    }\r\n\r\n    // Calculate TT hit rate (would need to be passed from search)\r\n    this.searchStats.ttHitRate = 0.85; // Placeholder\r\n  }\r\n\r\n  /**\r\n   * Format evaluation string for display\r\n   */\r\n  private formatEvaluation(\r\n    searchResult: any,\r\n    empties: number,\r\n    isEndgame: boolean\r\n  ): string {\r\n    const parts: string[] = [];\r\n\r\n    parts.push(`Score: ${searchResult.score}`);\r\n    parts.push(`Depth: ${searchResult.depth}`);\r\n    parts.push(`Nodes: ${searchResult.nodes?.toLocaleString() || 0}`);\r\n\r\n    if (searchResult.time) {\r\n      const nps = searchResult.nodes ? Math.round(searchResult.nodes / (searchResult.time / 1000)) : 0;\r\n      parts.push(`NPS: ${nps.toLocaleString()}`);\r\n    }\r\n\r\n    if (isEndgame) {\r\n      parts.push(`Endgame (${empties} empty)`);\r\n    }\r\n\r\n    if (searchResult.ttHits && searchResult.ttStores) {\r\n      const hitRate = Math.round((searchResult.ttHits / (searchResult.ttHits + searchResult.ttStores)) * 100);\r\n      parts.push(`TT: ${hitRate}%`);\r\n    }\r\n\r\n    return parts.join(' | ');\r\n  }\r\n\r\n  /**\r\n   * Update engine configuration\r\n   */\r\n  updateConfig(newConfig: Partial<EngineNeoConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n\r\n    // Update time manager if time config changed\r\n    if (newConfig.timeConfig) {\r\n      const timeConfig: TimeConfig = {\r\n        totalTime: 30000,\r\n        increment: 1000,\r\n        minThinkTime: 500,\r\n        maxThinkTime: 10000,\r\n        ...this.config.timeConfig\r\n      };\r\n      this.timeManager = new TimeManager(timeConfig);\r\n    }\r\n\r\n    // Resize transposition table if needed\r\n    if (newConfig.ttSize && newConfig.ttSize !== this.config.ttSize) {\r\n      this.tt = new TranspositionTable(newConfig.ttSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear engine state (between games)\r\n   */\r\n  clearState(): void {\r\n    this.tt.clear();\r\n    this.killers.clear();\r\n    this.history.clear();\r\n    this.searchStats = {\r\n      totalNodes: 0,\r\n      totalSearches: 0,\r\n      avgDepth: 0,\r\n      ttHitRate: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get engine statistics\r\n   */\r\n  getStats(): typeof this.searchStats & {\r\n    timeStats: ReturnType<TimeManager['getStats']>;\r\n    ttStats: ReturnType<TranspositionTable['getStats']>;\r\n  } {\r\n    return {\r\n      ...this.searchStats,\r\n      timeStats: this.timeManager.getStats(),\r\n      ttStats: this.tt.getStats()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get engine name and version\r\n   */\r\n  getName(): string {\r\n    return 'Engine-Neo v1.0';\r\n  }\r\n\r\n  /**\r\n   * Get supported features\r\n   */\r\n  getFeatures(): string[] {\r\n    return [\r\n      'Principal Variation Search',\r\n      'Aspiration Windows',\r\n      'Transposition Table',\r\n      'Move Ordering (Killers + History)',\r\n      'Dynamic Time Management',\r\n      'Multi-phase Evaluation',\r\n      'Configurable Difficulty',\r\n      'Endgame Solver'\r\n    ];\r\n  }\r\n\r\n  private countEmptySquares(board: Board): number {\r\n    let count = 0;\r\n    for (let r = 0; r < 8; r++) {\r\n      for (let c = 0; c < 8; c++) {\r\n        if (board[r][c] === null) count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n}\r\n\r\n// Instantiate default engine instance for consumers expecting ready-to-use engine\nexport const engineNeo = new EngineNeo();\n\nexport default engineNeo;\n\r\n// Export search components for advanced usage\nexport { AspirationEngine } from './search/aspiration';\nexport { TimeManager } from './search/timeManager';\nexport { TranspositionTable } from './optimization/transTable';\nexport { KillerMoves, HistoryTable } from './ordering/moveOrdering';\n\n// Export evaluation and configuration utilities\nexport * from './evaluation/heuristic';\nexport * from './config/selectivity';\n\n// Export type helpers\nexport type { AspirationConfig } from './search/aspiration';\nexport type { TimeConfig } from './search/timeManager';\n\nexport { DEFAULT_ASPIRATION_CONFIG } from './search/aspiration';\n"],
  "mappings": "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",
  "names": ["DifficultyLevel", "opponent", "getValidMoves"]
}
