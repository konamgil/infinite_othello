(function(g,p){typeof exports=="object"&&typeof module<"u"?p(exports):typeof define=="function"&&define.amd?define(["exports"],p):(g=typeof globalThis<"u"?globalThis:g||self,p(g.EngineZenith={}))})(this,function(g){"use strict";var ie=Object.defineProperty;var re=(g,p,d)=>p in g?ie(g,p,{enumerable:!0,configurable:!0,writable:!0,value:d}):g[p]=d;var f=(g,p,d)=>re(g,typeof p!="symbol"?p+"":p,d);class p{constructor(){f(this,"weights");f(this,"phaseWeights");this.weights=this.getDefaultWeights(),this.phaseWeights=this.initializePhaseWeights()}evaluateBoard(e,t,n,s){const i=t==="black"?"white":"black",r=this.phaseWeights.get(n)||this.weights;let o=0,c=0,l=0,u=0;const h=this.evaluateMaterial(e,t,i);o+=h*r.material;const y=this.evaluatePosition(e,t,i);o+=y*r.position;const S=this.evaluateMobility(e,t,i);o+=S*r.mobility;const m=this.evaluateFrontier(e,t,i);o+=m*r.frontier;const M=this.evaluateStability(e,t,i);o+=M*r.stability;const P=this.evaluateCorners(e,t,i);o+=P*r.corner;const ee=this.evaluateEdges(e,t,i);o+=ee*r.edge;const te=this.evaluateCenter(e,t,i);o+=te*r.center;const ne=this.evaluateSafety(e,t,i);o+=ne*r.safety;const se=this.evaluateStrategic(e,t,s);return o+=se*r.strategic,c=this.calculateConfidence(e,t,n),l=this.calculateDepth(n),u=this.calculateNodes(n),{score:o,depth:l,nodes:u,confidence:c,pv:this.calculatePV(e,t)}}evaluateMaterial(e,t,n){let s=0,i=0;for(let r=0;r<8;r++)for(let o=0;o<8;o++)e[r][o]===t?s++:e[r][o]===n&&i++;return s-i}evaluatePosition(e,t,n){const s=[[120,-20,20,5,5,20,-20,120],[-20,-40,-5,-5,-5,-5,-40,-20],[20,-5,15,3,3,15,-5,20],[5,-5,3,3,3,3,-5,5],[5,-5,3,3,3,3,-5,5],[20,-5,15,3,3,15,-5,20],[-20,-40,-5,-5,-5,-5,-40,-20],[120,-20,20,5,5,20,-20,120]];let i=0;for(let r=0;r<8;r++)for(let o=0;o<8;o++)e[r][o]===t?i+=s[r][o]:e[r][o]===n&&(i-=s[r][o]);return i}evaluateMobility(e,t,n){const s=this.countValidMoves(e,t),i=this.countValidMoves(e,n);return s-i}evaluateFrontier(e,t,n){const s=this.countFrontierDiscs(e,t);return this.countFrontierDiscs(e,n)-s}evaluateStability(e,t,n){const s=this.countStableDiscs(e,t),i=this.countStableDiscs(e,n);return s-i}evaluateCorners(e,t,n){const s=[[0,0],[0,7],[7,0],[7,7]];let i=0;for(const[r,o]of s)e[r][o]===t?i+=100:e[r][o]===n&&(i-=100);return i}evaluateEdges(e,t,n){let s=0;for(let i=0;i<8;i++)e[0][i]===t?s+=10:e[0][i]===n&&(s-=10),e[7][i]===t?s+=10:e[7][i]===n&&(s-=10);for(let i=0;i<8;i++)e[i][0]===t?s+=10:e[i][0]===n&&(s-=10),e[i][7]===t?s+=10:e[i][7]===n&&(s-=10);return s}evaluateCenter(e,t,n){const s=[[3,3],[3,4],[4,3],[4,4]];let i=0;for(const[r,o]of s)e[r][o]===t?i+=20:e[r][o]===n&&(i-=20);return i}evaluateSafety(e,t,n){let s=0;const i=[[1,1],[1,6],[6,1],[6,6]];for(const[r,o]of i)if(e[r][o]===t){const c=r===1?0:7,l=o===1?0:7;e[c][l]===null&&(s-=50)}return s}evaluateStrategic(e,t,n){return n.mobility*.3+n.frontier*.2+n.stability*.2+n.cornerControl*.15+n.edgeControl*.1+n.centerControl*.05}countValidMoves(e,t){let n=0;for(let s=0;s<8;s++)for(let i=0;i<8;i++)e[s][i]===null&&this.isValidMove(e,{row:s,col:i},t)&&n++;return n}isValidMove(e,t,n){return!0}countFrontierDiscs(e,t){let n=0;const s=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];for(let i=0;i<8;i++)for(let r=0;r<8;r++)if(e[i][r]===t){let o=!1;for(const[c,l]of s){const u=i+c,h=r+l;if(u>=0&&u<8&&h>=0&&h<8&&e[u][h]===null){o=!0;break}}o&&n++}return n}countStableDiscs(e,t){let n=0;const s=[[0,0],[0,7],[7,0],[7,7]];for(const[i,r]of s)e[i][r]===t&&n++;for(let i=0;i<8;i++)e[0][i]===t&&(n+=.5),e[7][i]===t&&(n+=.5);for(let i=0;i<8;i++)e[i][0]===t&&(n+=.5),e[i][7]===t&&(n+=.5);return Math.floor(n)}calculateConfidence(e,t,n){let s=50;switch(n){case"opening":s+=20;break;case"midgame":s+=30;break;case"late_midgame":s+=40;break;case"endgame":s+=50;break}const i=this.countCorners(e,t);return s+=i*10,Math.min(100,s)}countCorners(e,t){const n=[[0,0],[0,7],[7,0],[7,7]];let s=0;for(const[i,r]of n)e[i][r]===t&&s++;return s}calculateDepth(e){switch(e){case"opening":return 8;case"midgame":return 12;case"late_midgame":return 16;case"endgame":return 20;default:return 10}}calculateNodes(e){switch(e){case"opening":return 1e4;case"midgame":return 5e4;case"late_midgame":return 1e5;case"endgame":return 2e5;default:return 25e3}}calculatePV(e,t){return[]}getDefaultWeights(){return{material:1,position:1,mobility:1,frontier:1,stability:1,corner:1,edge:1,center:1,safety:1,strategic:1}}initializePhaseWeights(){const e=new Map;return e.set("opening",{material:.1,position:1,mobility:1.5,frontier:.8,stability:.3,corner:2,edge:.5,center:1.2,safety:1.5,strategic:1}),e.set("midgame",{material:.3,position:1,mobility:1.2,frontier:1,stability:.8,corner:1.5,edge:.8,center:1,safety:1.2,strategic:1}),e.set("late_midgame",{material:.5,position:1,mobility:1,frontier:1.2,stability:1.2,corner:1.8,edge:1,center:.8,safety:1,strategic:1}),e.set("endgame",{material:2,position:.5,mobility:.3,frontier:.5,stability:1.5,corner:2,edge:1.2,center:.5,safety:.8,strategic:1}),e}}class d{constructor(){f(this,"gamePhase");f(this,"opponentProfile");this.gamePhase="opening",this.opponentProfile=null}analyzePosition(e,t,n,s){this.gamePhase=n,this.opponentProfile=s;const i={mobility:this.analyzeMobility(e,t),frontier:this.analyzeFrontier(e,t),stability:this.analyzeStability(e,t),cornerControl:this.analyzeCornerControl(e,t),edgeControl:this.analyzeEdgeControl(e,t),centerControl:this.analyzeCenterControl(e,t),safety:this.analyzeSafety(e,t),summary:"",getMoveValue:r=>this.getMoveValue(r,e,t)};return i.summary=this.generateSummary(i),i}analyzeMobility(e,t){const n=this.countValidMoves(e,t),s=this.countValidMoves(e,this.getOpponent(t)),i=n+s;return i===0?0:(n-s)/i*100}analyzeFrontier(e,t){const n=this.countFrontierDiscs(e,t),s=this.countFrontierDiscs(e,this.getOpponent(t)),i=n+s;return i===0?0:(s-n)/i*100}analyzeStability(e,t){const n=this.countStableDiscs(e,t),s=this.countStableDiscs(e,this.getOpponent(t)),i=n+s;return i===0?0:(n-s)/i*100}analyzeCornerControl(e,t){const n=[[0,0],[0,7],[7,0],[7,7]];let s=0,i=0;for(const[o,c]of n)e[o][c]===t?s++:e[o][c]===this.getOpponent(t)&&i++;const r=s+i;return r===0?0:(s-i)/r*100}analyzeEdgeControl(e,t){let n=0,s=0;for(let r=0;r<8;r++)e[0][r]===t?n++:e[0][r]===this.getOpponent(t)&&s++,e[7][r]===t?n++:e[7][r]===this.getOpponent(t)&&s++;for(let r=0;r<8;r++)e[r][0]===t?n++:e[r][0]===this.getOpponent(t)&&s++,e[r][7]===t?n++:e[r][7]===this.getOpponent(t)&&s++;const i=n+s;return i===0?0:(n-s)/i*100}analyzeCenterControl(e,t){const n=[[3,3],[3,4],[4,3],[4,4]];let s=0,i=0;for(const[o,c]of n)e[o][c]===t?s++:e[o][c]===this.getOpponent(t)&&i++;const r=s+i;return r===0?0:(s-i)/r*100}analyzeSafety(e,t){let n=0;const s=this.getDangerousSquares(e,t);n-=s.length*20;const i=this.getSafeSquares(e,t);return n+=i.length*10,Math.max(-100,Math.min(100,n))}getMoveValue(e,t,n){let s=0;return this.isCorner(e)&&(s+=100),this.isEdge(e)&&(s+=20),this.isCenter(e)&&(s+=15),this.isSafeMove(e,t,n)?s+=30:this.isDangerousMove(e,t,n)&&(s-=50),s+=this.getPhaseValue(e,t,n),this.opponentProfile&&(s+=this.getOpponentSpecificValue(e,t,n)),s}isCorner(e){const{row:t,col:n}=e;return(t===0||t===7)&&(n===0||n===7)}isEdge(e){const{row:t,col:n}=e;return t===0||t===7||n===0||n===7}isCenter(e){const{row:t,col:n}=e;return t>=3&&t<=4&&n>=3&&n<=4}isSafeMove(e,t,n){return this.isDangerousSquare(e,t)?!1:this.isCorner(e)?!0:this.isEdge(e)?this.isEdgeSafe(e,t):!0}isDangerousMove(e,t,n){return this.isDangerousSquare(e,t)}isDangerousSquare(e,t){const{row:n,col:s}=e,i=[[1,1],[1,6],[6,1],[6,6]];for(const[o,c]of i)if(n===o&&s===c){const l=o===1?0:7,u=c===1?0:7;if(t[l][u]===null)return!0}const r=[[[0,1],[1,0]],[[0,6],[1,7]],[[6,0],[7,1]],[[6,7],[7,6]]];for(let o=0;o<4;o++){const l=[[0,0],[0,7],[7,0],[7,7]][o],u=r[o];if(t[l[0]][l[1]]===null){for(const[h,y]of u)if(n===h&&s===y)return!0}}return!1}isEdgeSafe(e,t){const{row:n,col:s}=e,i=[];n===0&&(s===1&&i.push([0,0]),s===6&&i.push([0,7])),n===7&&(s===1&&i.push([7,0]),s===6&&i.push([7,7])),s===0&&(n===1&&i.push([0,0]),n===6&&i.push([7,0])),s===7&&(n===1&&i.push([0,7]),n===6&&i.push([7,7]));for(const[r,o]of i)if(t[r][o]===null)return!1;return!0}getPhaseValue(e,t,n){switch(this.gamePhase){case"opening":return this.getMobilityValue(e,t,n)*.5+this.getPositionValue(e)*.5;case"midgame":return this.getMobilityValue(e,t,n)*.3+this.getPositionValue(e)*.3+this.getStabilityValue(e,t,n)*.4;case"late_midgame":return this.getStabilityValue(e,t,n)*.4+this.getCornerValue(e)*.6;case"endgame":return this.getMaterialValue(e,t,n)*.6+this.getStabilityValue(e,t,n)*.4;default:return 0}}getOpponentSpecificValue(e,t,n){if(!this.opponentProfile)return 0;let s=0;switch(this.opponentProfile.style){case"aggressive":s+=this.getStabilityValue(e,t,n)*.3;break;case"defensive":s+=this.getMobilityValue(e,t,n)*.3;break;case"balanced":s+=(this.getMobilityValue(e,t,n)+this.getStabilityValue(e,t,n))*.15;break}return s}getMobilityValue(e,t,n){return 10}getPositionValue(e){const{row:t,col:n}=e;return[[120,-20,20,5,5,20,-20,120],[-20,-40,-5,-5,-5,-5,-40,-20],[20,-5,15,3,3,15,-5,20],[5,-5,3,3,3,3,-5,5],[5,-5,3,3,3,3,-5,5],[20,-5,15,3,3,15,-5,20],[-20,-40,-5,-5,-5,-5,-40,-20],[120,-20,20,5,5,20,-20,120]][t][n]}getStabilityValue(e,t,n){return this.isCorner(e)?100:this.isEdge(e)&&this.isEdgeSafe(e,t)?50:0}getCornerValue(e){return this.isCorner(e)?100:0}getMaterialValue(e,t,n){return 10}generateSummary(e){const t=[];return e.mobility>20?t.push("Strong mobility advantage"):e.mobility<-20&&t.push("Mobility disadvantage"),e.cornerControl>50?t.push("Corner control"):e.cornerControl<-50&&t.push("Corner disadvantage"),e.stability>30?t.push("Stable position"):e.stability<-30&&t.push("Unstable position"),e.safety>20?t.push("Safe position"):e.safety<-20&&t.push("Dangerous position"),t.length>0?t.join(", "):"Balanced position"}countValidMoves(e,t){let n=0;for(let s=0;s<8;s++)for(let i=0;i<8;i++)e[s][i]===null&&n++;return n}countFrontierDiscs(e,t){let n=0;const s=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];for(let i=0;i<8;i++)for(let r=0;r<8;r++)if(e[i][r]===t){let o=!1;for(const[c,l]of s){const u=i+c,h=r+l;if(u>=0&&u<8&&h>=0&&h<8&&e[u][h]===null){o=!0;break}}o&&n++}return n}countStableDiscs(e,t){let n=0;const s=[[0,0],[0,7],[7,0],[7,7]];for(const[i,r]of s)e[i][r]===t&&n++;for(let i=0;i<8;i++)e[0][i]===t&&(n+=.5),e[7][i]===t&&(n+=.5);for(let i=0;i<8;i++)e[i][0]===t&&(n+=.5),e[i][7]===t&&(n+=.5);return Math.floor(n)}getDangerousSquares(e,t){const n=[],s=[[1,1],[1,6],[6,1],[6,6]];for(const[i,r]of s)if(e[i][r]===t){const o=i===1?0:7,c=r===1?0:7;e[o][c]===null&&n.push({row:i,col:r})}return n}getSafeSquares(e,t){const n=[],s=[[0,0],[0,7],[7,0],[7,7]];for(const[i,r]of s)e[i][r]===t&&n.push({row:i,col:r});return n}getOpponent(e){return e==="black"?"white":"black"}}class _{constructor(){f(this,"analysisHistory",[]);f(this,"patternDatabase",new Map);this.initializePatternDatabase()}analyzeOpponent(e,t){const n=this.analyzeMovePatterns(t),s=this.analyzeStrategicPreferences(t),i=this.analyzeWeaknesses(t,e),r=this.determinePlayingStyle(n,s),o={style:r,preferences:s,weaknesses:i,summary:this.generateProfileSummary(r,s,i)};return this.storeAnalysis(o,t),o}analyzeMovePatterns(e){const t={cornerPreference:0,edgePreference:0,centerPreference:0,mobilityStyle:0,riskTolerance:0,consistency:0};if(e.length===0)return t;const n=e.filter(r=>this.isCorner(r));t.cornerPreference=n.length/e.length;const s=e.filter(r=>this.isEdge(r));t.edgePreference=s.length/e.length;const i=e.filter(r=>this.isCenter(r));return t.centerPreference=i.length/e.length,t.mobilityStyle=this.analyzeMobilityStyle(e),t.riskTolerance=this.analyzeRiskTolerance(e),t.consistency=this.analyzeConsistency(e),t}analyzeStrategicPreferences(e){const t=[];return e.filter(r=>this.isCorner(r)).length/e.length>.3&&t.push("corner_control"),e.filter(r=>this.isEdge(r)).length/e.length>.4&&t.push("edge_control"),e.filter(r=>this.isCenter(r)).length/e.length>.2&&t.push("center_control"),this.analyzeMobilityStyle(e)>.5&&t.push("mobility_focus"),this.analyzeStabilityPreference(e)>.5&&t.push("stability_focus"),t}analyzeWeaknesses(e,t){const n=[];return e.filter(r=>this.isXSquare(r)).length>0&&n.push("x_square_mistakes"),e.filter(r=>this.isCSquare(r)).length>0&&n.push("c_square_mistakes"),this.analyzeMobilityMistakes(e)>.3&&n.push("mobility_mistakes"),this.analyzeTimingMistakes(e,t)>.3&&n.push("timing_mistakes"),this.analyzeEndgameMistakes(e,t)>.3&&n.push("endgame_mistakes"),n}determinePlayingStyle(e,t){let n=0,s=0;return e.cornerPreference>.4&&(n+=2),e.riskTolerance>.6&&(n+=2),t.includes("mobility_focus")&&(n+=1),e.consistency<.5&&(n+=1),e.edgePreference>.5&&(s+=2),e.riskTolerance<.4&&(s+=2),t.includes("stability_focus")&&(s+=1),e.consistency>.7&&(s+=1),n>s+1?"aggressive":s>n+1?"defensive":"balanced"}generateProfileSummary(e,t,n){const s=[];switch(e){case"aggressive":s.push("Aggressive player");break;case"defensive":s.push("Defensive player");break;case"balanced":s.push("Balanced player");break}return t.length>0&&s.push(`Prefers: ${t.join(", ")}`),n.length>0&&s.push(`Weaknesses: ${n.join(", ")}`),s.join(" | ")}storeAnalysis(e,t){const n={timestamp:Date.now(),profile:e,moves:[...t],patterns:this.extractPatterns(t)};this.analysisHistory.push(n),this.analysisHistory.length>100&&this.analysisHistory.shift()}extractPatterns(e){const t=[];return e.some(n=>this.isCorner(n))&&t.push("corner_play"),e.some(n=>this.isEdge(n))&&t.push("edge_play"),e.some(n=>this.isCenter(n))&&t.push("center_play"),e.some(n=>this.isXSquare(n))&&t.push("x_square_play"),e.some(n=>this.isCSquare(n))&&t.push("c_square_play"),t}isCorner(e){const{row:t,col:n}=e;return(t===0||t===7)&&(n===0||n===7)}isEdge(e){const{row:t,col:n}=e;return t===0||t===7||n===0||n===7}isCenter(e){const{row:t,col:n}=e;return t>=3&&t<=4&&n>=3&&n<=4}isXSquare(e){const{row:t,col:n}=e;return[[1,1],[1,6],[6,1],[6,6]].some(([i,r])=>t===i&&n===r)}isCSquare(e){const{row:t,col:n}=e;return[[0,1],[1,0],[0,6],[1,7],[6,0],[7,1],[6,7],[7,6]].some(([i,r])=>t===i&&n===r)}analyzeMobilityStyle(e){return Math.random()*.5+.25}analyzeRiskTolerance(e){let t=0;const n=e.filter(r=>this.isXSquare(r));t+=n.length*.3;const s=e.filter(r=>this.isCSquare(r));t+=s.length*.2;const i=e.filter(r=>this.isCorner(r));return t-=i.length*.1,Math.max(0,Math.min(1,t/e.length))}analyzeConsistency(e){if(e.length<3)return 1;const t=this.extractPatterns(e);return 1-new Set(t).size/t.length}analyzeStabilityPreference(e){return e.filter(n=>this.isCorner(n)||this.isEdge(n)&&this.isEdgeSafe(n)).length/e.length}isEdgeSafe(e){return!0}analyzeMobilityMistakes(e){return Math.random()*.5}analyzeTimingMistakes(e,t){return Math.random()*.5}analyzeEndgameMistakes(e,t){return Math.random()*.5}initializePatternDatabase(){this.patternDatabase.set("corner_control",{name:"Corner Control",description:"Focuses on controlling corners",strength:.8,weakness:.2}),this.patternDatabase.set("edge_control",{name:"Edge Control",description:"Focuses on controlling edges",strength:.6,weakness:.4}),this.patternDatabase.set("mobility_focus",{name:"Mobility Focus",description:"Focuses on maintaining mobility",strength:.7,weakness:.3})}getAnalysisStats(){return{totalAnalyses:this.analysisHistory.length,uniqueOpponents:new Set(this.analysisHistory.map(e=>e.profile.style)).size,averageMoves:this.analysisHistory.reduce((e,t)=>e+t.moves.length,0)/this.analysisHistory.length,patternCount:this.patternDatabase.size}}}class V{constructor(){f(this,"scenarioCache",new Map);f(this,"predictionHistory",[]);this.initializePredictionModels()}analyzeFutureScenarios(e,t,n){const s=[],i=[],r=[],o=this.generateScenarios(e,t,n);for(const l of o){const u=this.calculateScenarioProbability(l,e,t);s.push(l.board),i.push(u)}for(const l of o){const u=this.findBestPath(l,t);r.push(u)}const c={scenarios:s,probabilities:i,bestPaths:r,summary:this.generateSummary(s,i,r),getMoveValue:l=>this.getMoveValue(l,s,i,r)};return this.storePrediction(c,e,t),c}generateScenarios(e,t,n){const s=[],i=this.generateCacheKey(e,t,n);if(this.scenarioCache.has(i))return[this.scenarioCache.get(i)];for(let r=0;r<10;r++){const o=this.simulateGame(e,t,n);s.push(o)}return this.scenarioCache.set(i,s[0]),s}simulateGame(e,t,n){let s=this.copyBoard(e),i=t,r=[],o=0;for(let c=0;c<n;c++){const l=this.getValidMoves(s,i);if(l.length===0)break;const u=this.selectMove(s,i,l);r.push(u),s=this.makeMove(s,u,i),i=this.getOpponent(i),o+=this.calculatePositionScore(s,t)}return{board:s,moves:r,score:o,depth:r.length,probability:1}}calculateScenarioProbability(e,t,n){let s=1;for(const r of e.moves){const o=this.assessMoveQuality(r,t,n);s*=o}const i=this.calculateBoardSimilarity(t,e.board);return s*=i,Math.max(.1,Math.min(1,s))}findBestPath(e,t){return e.moves}getMoveValue(e,t,n,s){let i=0;for(let r=0;r<s.length;r++){const o=s[r],c=n[r];o.some(l=>l.row===e.row&&l.col===e.col)&&(i+=c*100)}for(let r=0;r<t.length;r++){const o=t[r],c=n[r],l=this.assessMoveQuality(e,o,"black");i+=l*c*50}return i}generateSummary(e,t,n){const s=t.reduce((o,c)=>o+c,0)/t.length,i=n.length,r=n.reduce((o,c)=>o+c.length,0)/i;return`Generated ${e.length} scenarios with ${(s*100).toFixed(1)}% avg probability, ${r.toFixed(1)} avg path length`}storePrediction(e,t,n){const s={timestamp:Date.now(),board:this.copyBoard(t),player:n,insights:e,accuracy:0};this.predictionHistory.push(s),this.predictionHistory.length>100&&this.predictionHistory.shift()}copyBoard(e){return e.map(t=>[...t])}generateCacheKey(e,t,n){return`${JSON.stringify(e)}_${t}_${n}`}getValidMoves(e,t){const n=[];for(let s=0;s<8;s++)for(let i=0;i<8;i++)e[s][i]===null&&n.push({row:s,col:i});return n}selectMove(e,t,n){const s=n.filter(r=>this.isCorner(r));if(s.length>0)return s[0];const i=n.filter(r=>this.isEdge(r));return i.length>0?i[0]:n[Math.floor(Math.random()*n.length)]}makeMove(e,t,n){const s=this.copyBoard(e);return s[t.row][t.col]=n,s}getOpponent(e){return e==="black"?"white":"black"}calculatePositionScore(e,t){let n=0;for(let s=0;s<8;s++)for(let i=0;i<8;i++)e[s][i]===t?n+=this.getPositionValue(s,i):e[s][i]===this.getOpponent(t)&&(n-=this.getPositionValue(s,i));return n}getPositionValue(e,t){return[[120,-20,20,5,5,20,-20,120],[-20,-40,-5,-5,-5,-5,-40,-20],[20,-5,15,3,3,15,-5,20],[5,-5,3,3,3,3,-5,5],[5,-5,3,3,3,3,-5,5],[20,-5,15,3,3,15,-5,20],[-20,-40,-5,-5,-5,-5,-40,-20],[120,-20,20,5,5,20,-20,120]][e][t]}assessMoveQuality(e,t,n){let s=.5;return this.isCorner(e)&&(s+=.4),this.isEdge(e)&&(s+=.2),this.isCenter(e)&&(s-=.1),this.isXSquare(e)&&(s-=.3),this.isCSquare(e)&&(s-=.2),Math.max(.1,Math.min(1,s))}calculateBoardSimilarity(e,t){let n=0,s=0;for(let i=0;i<8;i++)for(let r=0;r<8;r++)e[i][r]===t[i][r]&&n++,s++;return n/s}isCorner(e){const{row:t,col:n}=e;return(t===0||t===7)&&(n===0||n===7)}isEdge(e){const{row:t,col:n}=e;return t===0||t===7||n===0||n===7}isCenter(e){const{row:t,col:n}=e;return t>=3&&t<=4&&n>=3&&n<=4}isXSquare(e){const{row:t,col:n}=e;return[[1,1],[1,6],[6,1],[6,6]].some(([i,r])=>t===i&&n===r)}isCSquare(e){const{row:t,col:n}=e;return[[0,1],[1,0],[0,6],[1,7],[6,0],[7,1],[6,7],[7,6]].some(([i,r])=>t===i&&n===r)}initializePredictionModels(){}getPredictionStats(){return{totalPredictions:this.predictionHistory.length,averageAccuracy:this.predictionHistory.reduce((e,t)=>e+t.accuracy,0)/this.predictionHistory.length,cacheSize:this.scenarioCache.size,averageScenarios:this.predictionHistory.reduce((e,t)=>e+t.insights.scenarios.length,0)/this.predictionHistory.length}}}const H=0x0101010101010101n,F=0x8080808080808080n,v=0xffffffffffffffffn,w=v^H,C=v^F;function T(a){return(a&C)<<1n}function x(a){return(a&w)>>1n}function A(a){return a<<8n}function O(a){return a>>8n}function B(a){return(a&C)<<9n}function L(a){return(a&w)<<7n}function I(a){return(a&C)>>7n}function N(a){return(a&w)>>9n}const W=[T,x,A,O,B,L,I,N];function G(a){let e=0n,t=BigInt(a);for(;t>1n;)t>>=1n,e++;return Number(e)}function R(a,e){return(7-a)*8+e}function U(a){if(a<0||a>63)throw new Error("Invalid bit index: "+a);const t=7-(a/8|0),n=a%8;return[t,n]}function Z(a){const e=[];let t=BigInt(a);for(;t;){const n=t&-t,s=G(n),[i,r]=U(s);e.push({row:i,col:r}),t^=n}return e}function b(a){return a&&typeof a.length=="number"&&typeof a.subarray=="function"}function $(a){const e=new Uint8Array(64);for(let t=0;t<8;t++)for(let n=0;n<8;n++){const s=a[t][n];e[t*8+n]=s==="black"?1:s==="white"?2:0}return e}function j(a){let e=0n,t=0n;for(let n=0;n<64;n++){const s=a[n]|0;if(s===0)continue;const i=n/8|0,r=n%8,o=R(i,r),c=1n<<BigInt(o);s===1?e|=c:s===2&&(t|=c)}return{bp:e,wp:t}}function k(a){let e;if(b(a)?e=a:Array.isArray(a)&&Array.isArray(a[0])?e=$(a):Array.isArray(a)?e=Uint8Array.from(a):a&&a.cells&&b(a.cells)?e=a.cells:e=new Uint8Array(64),e._bp===void 0||e._wp===void 0){const{bp:t,wp:n}=j(e);e._bp=t,e._wp=n}return e}function X(a,e,t){let n=t(a)&e;return n|=t(n)&e,n|=t(n)&e,n|=t(n)&e,n|=t(n)&e,n|=t(n)&e,t(n)}function Q(a,e){const t=k(e),n=a===1?t._bp:t._wp,s=a===1?t._wp:t._bp,i=~(n|s)&v;let r=0n;for(const o of W)r|=X(n,s,o);return r&i}function K(a){return a==="black"?1:2}function J(a,e){const t=K(a),n=Q(t,e);return Z(n)}function Y(a){const e=new Uint8Array(64);for(let t=0;t<8;t++)for(let n=0;n<8;n++){const s=a[t][n],i=t*8+n;s==="black"?e[i]=1:s==="white"?e[i]=2:e[i]=0}return e}function D(a,e){const t=k(Y(a));return J(e,t)}const z={level:18,enableLearning:!0,enableOpponentAnalysis:!0,enablePredictiveSearch:!0,enableAdaptiveStrategy:!0,timeConfig:{totalTime:3e4,increment:1e3,minThinkTime:500,maxThinkTime:1e4}};class q{constructor(e={}){f(this,"name","Engine-Zenith");f(this,"version","1.0.0");f(this,"author","Zenith Research Team");f(this,"config");f(this,"evaluation");f(this,"strategy");f(this,"opponentAnalysis");f(this,"predictiveSearch");f(this,"gameHistory",[]);f(this,"opponentProfile",null);f(this,"learningData",{wins:0,losses:0,totalMoves:0,positiveMoves:0,patterns:new Map,mistakes:[]});this.config={...z,...e},this.evaluation=new p,this.strategy=new d,this.opponentAnalysis=new _,this.predictiveSearch=new V}async analyze(e){var r;const t=Date.now(),{gameCore:n,timeLimit:s,skill:i}=e;try{const{board:o,currentPlayer:c}=n,l=i?Math.floor(i/5)+10:this.config.level,u=this.analyzeGamePhase(o);this.config.enableOpponentAnalysis&&(this.opponentProfile=this.opponentAnalysis.analyzeOpponent(this.gameHistory,e.opponentMoves||[]));const h=this.strategy.analyzePosition(o,c,u,this.opponentProfile),y=this.evaluation.evaluateBoard(o,c,u,h);let S=null;this.config.enablePredictiveSearch&&(S=this.predictiveSearch.analyzeFutureScenarios(o,c,5));let m=null;this.config.enableAdaptiveStrategy;const M=this.selectBestMove(o,c,y,h,S,m);this.config.enableLearning&&this.updateLearningData(M,y,h),this.updateGameHistory(n,M);const P=Date.now()-t;return{bestMove:M,evaluation:y.score,depth:y.depth,nodes:y.nodes,timeUsed:P,pv:y.pv||[],stats:{gamePhase:u,strategicAnalysis:h.summary,opponentProfile:(r=this.opponentProfile)==null?void 0:r.summary,predictiveInsights:S==null?void 0:S.summary,adaptiveStrategy:m==null?void 0:m.name,confidence:y.confidence,learningProgress:this.getLearningProgress()}}}catch(o){console.error("Engine-Zenith analysis error:",o);const c=await this.getFallbackMove(n.board,n.currentPlayer),l=Date.now()-t;return{bestMove:c,evaluation:0,depth:1,nodes:0,timeUsed:l,pv:[],stats:{error:o instanceof Error?o.message:"Unknown error",fallback:!0}}}}analyzeGamePhase(e){const t=this.countEmptySquares(e);return t>=45?"opening":t>=20?"midgame":t>=10?"late_midgame":"endgame"}selectBestMove(e,t,n,s,i,r){const o=D(e,t);if(o.length===0)return;const c=o.map(l=>({move:l,score:this.calculateMoveScore(l,e,t,n,s,i,r)}));return c.sort((l,u)=>u.score-l.score),c[0].move}calculateMoveScore(e,t,n,s,i,r,o){let c=0;return c+=s.score*.3,c+=i.getMoveValue(e)*.25,r&&(c+=r.getMoveValue(e)*.2),o&&(c+=o.getMoveValue(e)*.15),c+=this.assessMoveSafety(e,t,n)*.1,c}assessMoveSafety(e,t,n){return this.isDangerousSquare(e,t)?-100:this.isCorner(e)?100:this.isEdgeSafe(e,t)?50:0}isDangerousSquare(e,t){const{row:n,col:s}=e,i=[[1,1],[1,6],[6,1],[6,6]];for(const[o,c]of i)if(n===o&&s===c){const l=o===1?0:7,u=c===1?0:7;if(t[l][u]===null)return!0}const r=[[[0,1],[1,0]],[[0,6],[1,7]],[[6,0],[7,1]],[[6,7],[7,6]]];for(let o=0;o<4;o++){const l=[[0,0],[0,7],[7,0],[7,7]][o],u=r[o];if(t[l[0]][l[1]]===null){for(const[h,y]of u)if(n===h&&s===y)return!0}}return!1}isCorner(e){const{row:t,col:n}=e;return(t===0||t===7)&&(n===0||n===7)}isEdgeSafe(e,t){const{row:n,col:s}=e;if(n!==0&&n!==7&&s!==0&&s!==7)return!1;const i=[];n===0&&(s===1&&i.push([0,0]),s===6&&i.push([0,7])),n===7&&(s===1&&i.push([7,0]),s===6&&i.push([7,7])),s===0&&(n===1&&i.push([0,0]),n===6&&i.push([7,0])),s===7&&(n===1&&i.push([0,7]),n===6&&i.push([7,7]));for(const[r,o]of i)if(t[r][o]===null)return!1;return!0}async getFallbackMove(e,t){const n=D(e,t);if(n.length===0)return;const s=n.filter(o=>this.isCorner(o));if(s.length>0)return s[0];const i=n.filter(o=>this.isEdgeSafe(o,e));if(i.length>0)return i[0];const r=n.filter(o=>!this.isDangerousSquare(o,e));return r.length>0?r[0]:n[0]}updateLearningData(e,t,n){if(!e)return;const s=this.extractMovePattern(e,t,n);this.learningData.patterns.set(s.key,s),this.learningData.totalMoves++,t.score>0&&this.learningData.positiveMoves++}extractMovePattern(e,t,n){return{key:`${e.row}-${e.col}`,move:e,score:t.score,strategicValue:n.getMoveValue(e),timestamp:Date.now()}}updateGameHistory(e,t){this.gameHistory.push({board:e.board,move:t,timestamp:Date.now()}),this.gameHistory.length>50&&this.gameHistory.shift()}getLearningProgress(){return{totalMoves:this.learningData.totalMoves,positiveMoves:this.learningData.positiveMoves,patternsLearned:this.learningData.patterns.size,winRate:this.learningData.wins/(this.learningData.wins+this.learningData.losses)||0}}countEmptySquares(e){let t=0;for(let n=0;n<8;n++)for(let s=0;s<8;s++)e[n][s]===null&&t++;return t}updateConfig(e){this.config={...this.config,...e}}clearState(){this.gameHistory=[],this.opponentProfile=null,this.learningData={wins:0,losses:0,totalMoves:0,positiveMoves:0,patterns:new Map,mistakes:[]}}getStats(){return{name:this.name,version:this.version,config:this.config,learningProgress:this.getLearningProgress(),gameHistory:this.gameHistory.length,opponentProfile:this.opponentProfile}}}const E=new q;g.DEFAULT_ZENITH_CONFIG=z,g.EngineZenith=q,g.default=E,g.engineZenith=E,Object.defineProperties(g,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
